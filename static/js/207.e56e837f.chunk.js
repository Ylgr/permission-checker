"use strict";(self.webpackChunkpermission_checker=self.webpackChunkpermission_checker||[]).push([[207],{1207:(t,r,a)=>{a.d(r,{e:()=>P,f:()=>C});var e=a(4942),i=a(2257),c=a(9601),n=a(7588),s=a(1313),o=a(2655),p=a(4376),h=a(1137),l=a(6898),m=a(4554),d=a(4434),u=a(3778),W=a(7009);class g{constructor(t,r){(0,e.Z)(this,"featureName",s.cG.name),(0,e.Z)(this,"to",(0,h.c)((async t=>{const r=new n.C(this.contractWrapper),a=(await Promise.all(t.map((t=>Promise.all([(0,s.aP)(t.toAddress),this.erc20.normalizeAmount(t.amount)]))))).map((t=>{let[a,e]=t;return r.encode("mintTo",[a,e])}));return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[a]})}))),this.erc20=t,this.contractWrapper=r}}class y{constructor(t,r){(0,e.Z)(this,"featureName",s.cH.name),(0,e.Z)(this,"tokens",(0,h.c)((async t=>h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[await this.erc20.normalizeAmount(t)]})))),(0,e.Z)(this,"from",(0,h.c)((async(t,r)=>h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burnFrom",args:await Promise.all([(0,s.aP)(t),this.erc20.normalizeAmount(r)])})))),this.erc20=t,this.contractWrapper=r}}class w{constructor(t,r,a){(0,e.Z)(this,"featureName",s.cI.name),(0,e.Z)(this,"to",(0,h.c)((async(t,r,a)=>{const e=await this.erc20.normalizeAmount(r);return await this.conditions.getClaimTransaction(t,e,a)}))),this.erc20=t,this.contractWrapper=r,this.storage=a;const i=new p.C(this.contractWrapper,s.bk,this.storage);this.conditions=new l.D(this.contractWrapper,i,this.storage)}}class f{constructor(t,r,a){this.erc20=t,this.contractWrapper=r,this.storage=a,this.claim=new w(this.erc20,this.contractWrapper,this.storage)}}class b{constructor(t,r){(0,e.Z)(this,"featureName",s.cJ.name),(0,e.Z)(this,"to",(0,h.c)((async(t,r)=>await this.getMintTransaction(t,r)))),this.erc20=t,this.contractWrapper=r,this.batch=this.detectErc20BatchMintable()}async getMintTransaction(t,r){return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:await Promise.all([(0,s.aP)(t),this.erc20.normalizeAmount(r)])})}detectErc20BatchMintable(){if((0,p.d)(this.contractWrapper,"ERC20BatchMintable"))return new g(this.erc20,this.contractWrapper)}}class P{constructor(t,r){(0,e.Z)(this,"featureName",s.cK.name),(0,e.Z)(this,"mint",(0,h.c)((async t=>{const r=t.payload,a=t.signature,[e,c]=await Promise.all([this.mapPayloadToContractStruct(r),this.contractWrapper.getCallOverrides()]);return await(0,u.s)(this.contractWrapper,i.O$.from(e.price),r.currencyAddress,c),h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[e,a],overrides:c})}))),(0,e.Z)(this,"mintBatch",(0,h.c)((async t=>{const r=await Promise.all(t.map((t=>this.mapPayloadToContractStruct(t.payload)))),a=t.map(((t,a)=>{const e=r[a],c=t.signature,n=t.payload.price;if(i.O$.from(n).gt(0))throw new Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:e,signature:c}})),e=new n.C(this.contractWrapper),c=a.map((t=>e.encode("mintWithSignature",[t.message,t.signature])));return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[c]})}))),this.contractWrapper=t,this.roles=r}async verify(t){const r=t.payload,a=t.signature,e=await this.mapPayloadToContractStruct(r);return(await this.contractWrapper.read("verify",[e,a]))[0]}async generate(t){return(await this.generateBatch([t]))[0]}async generateBatch(t){var r;await(null===(r=this.roles)||void 0===r?void 0:r.verify(["minter"],await this.contractWrapper.getSignerAddress()));const[a,e,i]=await Promise.all([this.contractWrapper.getChainID(),this.contractWrapper.read("name",[]),Promise.all(t.map((t=>W.S.parseAsync(t))))]),c=this.contractWrapper.getSigner();(0,m.Z)(c,"No signer available");const n=await Promise.all(i.map((t=>W.k.parseAsync(t)))),s=await Promise.all(n.map((t=>this.mapPayloadToContractStruct(t)))),o=await Promise.all(s.map((t=>this.contractWrapper.signTypedData(c,{name:e,version:"1",chainId:a,verifyingContract:this.contractWrapper.address},{MintRequest:W.M},t))));return i.map(((t,r)=>({payload:n[r],signature:o[r].toString()})))}async mapPayloadToContractStruct(t){const[r,a]=await Promise.all([(0,d.n)(this.contractWrapper.getProvider(),t.price,t.currencyAddress),this.contractWrapper.read("decimals",[])]),e=c.parseUnits(t.quantity,a);return{to:t.to,primarySaleRecipient:t.primarySaleRecipient,quantity:e,price:r,currency:t.currencyAddress,validityEndTimestamp:t.mintEndTime,validityStartTimestamp:t.mintStartTime,uid:t.uid}}}class C{get chainId(){return this._chainId}constructor(t,r,a){(0,e.Z)(this,"featureName",s.cL.name),(0,e.Z)(this,"transfer",(0,h.c)((async(t,r)=>h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transfer",args:await Promise.all([(0,s.aP)(t),this.normalizeAmount(r)])})))),(0,e.Z)(this,"transferFrom",(0,h.c)((async(t,r,a)=>h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom",args:await Promise.all([(0,s.aP)(t),(0,s.aP)(r),this.normalizeAmount(a)])})))),(0,e.Z)(this,"setAllowance",(0,h.c)((async(t,r)=>h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approve",args:await Promise.all([(0,s.aP)(t),this.normalizeAmount(r)])})))),(0,e.Z)(this,"transferBatch",(0,h.c)((async t=>{const r=new n.C(this.contractWrapper),a=(await Promise.all(t.map((t=>Promise.all([this.normalizeAmount(t.amount),(0,s.aP)(t.toAddress)]))))).map((t=>{let[a,e]=t;return r.encode("transfer",[e,a])}));return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[a]})}))),(0,e.Z)(this,"mint",(0,h.c)((async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t)))),(0,e.Z)(this,"mintTo",(0,h.c)((async(t,r)=>(0,o.a)(this.mintable,s.cJ).to.prepare(t,r)))),(0,e.Z)(this,"mintBatchTo",(0,h.c)((async t=>{var r;return(0,o.a)(null===(r=this.mintable)||void 0===r?void 0:r.batch,s.cG).to.prepare(t)}))),(0,e.Z)(this,"burn",(0,h.c)((async t=>(0,o.a)(this.burnable,s.cH).tokens.prepare(t)))),(0,e.Z)(this,"burnFrom",(0,h.c)((async(t,r)=>(0,o.a)(this.burnable,s.cH).from.prepare(t,r)))),(0,e.Z)(this,"claim",(0,h.c)((async(t,r)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,r)))),(0,e.Z)(this,"claimTo",(0,h.c)((async(t,r,a)=>{var e;return(0,o.a)(null===(e=this.droppable)||void 0===e?void 0:e.claim,s.cI).to.prepare(t,r,a)}))),this.contractWrapper=t,this.storage=r,this.mintable=this.detectErc20Mintable(),this.burnable=this.detectErc20Burnable(),this.droppable=this.detectErc20Droppable(),this.signatureMintable=this.detectErc20SignatureMintable(),this._chainId=a}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(){return await(0,n.f)(this.contractWrapper.getProvider(),this.getAddress())}async balance(){return await this.balanceOf(await this.contractWrapper.getSignerAddress())}async balanceOf(t){return this.getValue(await this.contractWrapper.read("balanceOf",[await(0,s.aP)(t)]))}async totalSupply(){return await this.getValue(await this.contractWrapper.read("totalSupply",[]))}async allowance(t){const[r,a]=await Promise.all([this.contractWrapper.getSignerAddress(),(0,s.aP)(t)]);return await this.allowanceOf(r,a)}async allowanceOf(t,r){const a=await Promise.all([(0,s.aP)(t),(0,s.aP)(r)]);return await this.getValue(await this.contractWrapper.read("allowance",a))}async getMintTransaction(t,r){return(0,o.a)(this.mintable,s.cJ).getMintTransaction(t,r)}get claimConditions(){var t;return(0,o.a)(null===(t=this.droppable)||void 0===t?void 0:t.claim,s.cI).conditions}get signature(){return(0,o.a)(this.signatureMintable,s.cK)}async normalizeAmount(t){return async function(t,r){const a=await t.read("decimals",[]);return c.parseUnits(s.cz.parse(r),a)}(this.contractWrapper,t)}async getValue(t){return await(0,n.a)(this.contractWrapper.getProvider(),this.getAddress(),i.O$.from(t))}detectErc20Mintable(){if((0,p.d)(this.contractWrapper,"ERC20"))return new b(this,this.contractWrapper)}detectErc20Burnable(){if((0,p.d)(this.contractWrapper,"ERC20Burnable"))return new y(this,this.contractWrapper)}detectErc20Droppable(){if((0,p.d)(this.contractWrapper,"ERC20ClaimConditionsV1")||(0,p.d)(this.contractWrapper,"ERC20ClaimConditionsV2")||(0,p.d)(this.contractWrapper,"ERC20ClaimPhasesV1")||(0,p.d)(this.contractWrapper,"ERC20ClaimPhasesV2"))return new f(this,this.contractWrapper,this.storage)}detectErc20SignatureMintable(){if((0,p.d)(this.contractWrapper,"ERC20SignatureMintable"))return new P(this.contractWrapper)}}}}]);
//# sourceMappingURL=207.e56e837f.chunk.js.map