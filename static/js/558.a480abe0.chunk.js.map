{"version":3,"file":"static/js/558.a480abe0.chunk.js","mappings":"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","sources":["../node_modules/@thirdweb-dev/sdk/dist/assertEnabled-ea837eec.browser.esm.js","../node_modules/@thirdweb-dev/sdk/dist/setErc20Allowance-7df9a12a.browser.esm.js","../node_modules/@thirdweb-dev/merkletree/dist/thirdweb-dev-merkletree.esm.js","../node_modules/@thirdweb-dev/sdk/node_modules/uuid/dist/esm-browser/native.js","../node_modules/@thirdweb-dev/sdk/node_modules/uuid/dist/esm-browser/rng.js","../node_modules/@thirdweb-dev/sdk/node_modules/uuid/dist/esm-browser/stringify.js","../node_modules/@thirdweb-dev/sdk/node_modules/uuid/dist/esm-browser/v4.js","../node_modules/@thirdweb-dev/sdk/dist/signature-ab20f9e3.browser.esm.js","../node_modules/base64-js/index.js","../node_modules/buffer-reverse/index.js","../node_modules/buffer/index.js","../node_modules/fast-deep-equal/index.js","../node_modules/ieee754/index.js","../node_modules/treeify/treeify.js"],"sourcesContent":["import { BigNumber } from 'ethers';\nimport { z } from 'zod';\nimport { x as ExtensionNotImplementedError } from './index-827e427d.browser.esm.js';\n\nconst RawDateSchema = /* @__PURE__ */(() => z.union([z.date().transform(i => {\n  return BigNumber.from(Math.floor(i.getTime() / 1000));\n}), z.number().transform(i => {\n  return BigNumber.from(i);\n})]))();\n\n/**\n * Default to now\n */\nconst StartDateSchema = /* @__PURE__ */(() => RawDateSchema.default(new Date(0)))();\n\n/**\n * Default to 10 years from now\n */\nconst EndDateSchema = /* @__PURE__ */(() => RawDateSchema.default(new Date(Date.now() + 1000 * 60 * 60 * 24 * 365 * 10)))();\n\n/**\n * Checks whether the given DetectableFeature is defined\n * @internal\n * @param namespace - The namespace to check\n * @param feature - The corresponding feature\n */\nfunction assertEnabled(namespace, feature) {\n  if (!namespace) {\n    throw new ExtensionNotImplementedError(feature);\n  }\n  return namespace;\n}\n\nexport { EndDateSchema as E, RawDateSchema as R, StartDateSchema as S, assertEnabled as a };\n","import { cA as BigNumberTransformSchema, cB as FileOrBufferOrStringSchema, cC as HexColor, cu as ContractWrapper } from './index-827e427d.browser.esm.js';\nimport { z } from 'zod';\nimport { i as isNativeToken } from './fetchCurrencyValue-39f97190.browser.esm.js';\n\nconst PropertiesInput = /* @__PURE__ */(() => z.object({}).catchall(z.union([BigNumberTransformSchema, z.unknown()])))();\n\n/**\n * @internal\n */\nconst OptionalPropertiesInput = /* @__PURE__ */(() => z.union([z.array(PropertiesInput), PropertiesInput]).optional().nullable())();\n\n/**\n * @internal\n */\nconst BasicNFTInput = /* @__PURE__ */(() => z.object({\n  name: z.union([z.string(), z.number()]).optional().nullable(),\n  description: z.string().nullable().optional().nullable(),\n  image: FileOrBufferOrStringSchema.nullable().optional(),\n  animation_url: FileOrBufferOrStringSchema.optional().nullable()\n}))();\n\n/**\n * @internal\n */\nconst CommonNFTInput = /* @__PURE__ */(() => BasicNFTInput.extend({\n  external_url: FileOrBufferOrStringSchema.nullable().optional(),\n  background_color: HexColor.optional().nullable(),\n  properties: OptionalPropertiesInput,\n  attributes: OptionalPropertiesInput\n}).catchall(z.union([BigNumberTransformSchema, z.unknown()])))();\n\n/**\n * @internal\n */\nconst NFTInputOrUriSchema = /* @__PURE__ */(() => z.union([CommonNFTInput, z.string()]))();\n\n/**\n * @internal\n */\nconst CommonNFTOutput = /* @__PURE__ */(() => CommonNFTInput.extend({\n  id: z.string(),\n  uri: z.string(),\n  image: z.string().nullable().optional(),\n  external_url: z.string().nullable().optional(),\n  animation_url: z.string().nullable().optional()\n}))();\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\nasync function setErc20Allowance(contractToApprove, value, currencyAddress, overrides) {\n  if (isNativeToken(currencyAddress)) {\n    overrides[\"value\"] = value;\n  } else {\n    const ERC20Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC20.json')).default;\n    const signer = contractToApprove.getSigner();\n    const provider = contractToApprove.getProvider();\n    const erc20 = new ContractWrapper(signer || provider, currencyAddress, ERC20Abi, contractToApprove.options, contractToApprove.storage);\n    const owner = await contractToApprove.getSignerAddress();\n    const spender = contractToApprove.address;\n    const allowance = await erc20.read(\"allowance\", [owner, spender]);\n    if (allowance.lt(value)) {\n      // approve overrides the previous allowance, set it to the minimum required for this tx\n      await erc20.sendTransaction(\"approve\", [spender, value]);\n    }\n    return overrides;\n  }\n}\n\nexport { BasicNFTInput as B, CommonNFTOutput as C, NFTInputOrUriSchema as N, CommonNFTInput as a, setErc20Allowance as s };\n","import { Buffer } from 'buffer';\nimport reverse from 'buffer-reverse';\nimport { asTree } from 'treeify';\n\n// ADAPTED FROM https://github.com/merkletreejs/merkletreejs\nclass Base {\n  /**\n   * print\n   * @desc Prints out a visual representation of the merkle tree.\n   * @example\n   *```js\n   *tree.print()\n   *```\n   */\n  print() {\n    Base.print(this);\n  }\n\n  /**\n   * bufferIndexOf\n   * @desc Returns the first index of which given buffer is found in array.\n   * @param {Buffer[]} haystack - Array of buffers.\n   * @param {Buffer} needle - Buffer to find.\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = tree.bufferIndexOf(haystack, needle)\n   *```\n   */\n  bufferIndexOf(array, element) {\n    let isSorted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (isSorted) {\n      return this.binarySearch(array, element, Buffer.compare);\n    }\n    const eqChecker = (buffer1, buffer2) => buffer1.equals(buffer2);\n    return this.linearSearch(array, element, eqChecker);\n  }\n\n  /**\n   * binarySearch\n   * @desc Returns the first index of which given item is found in array using binary search.\n   * @param {Buffer[]} array - Array of items.\n   * @param {Buffer} element - Item to find.\n   * @param {Function} compareFunction\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = MerkleTree.binarySearch(array, element, Buffer.compare)\n   *```\n   */\n  static binarySearch(array, element, compareFunction) {\n    let start = 0;\n    let end = array.length - 1;\n\n    // Iterate while start not meets end\n    while (start <= end) {\n      // Find the mid index\n      const mid = Math.floor((start + end) / 2);\n\n      // Check if the mid value is greater than, equal to, or less than search element.\n      const ordering = compareFunction(array[mid], element);\n\n      // If element is present at mid, start iterating for searching first appearance.\n      if (ordering === 0) {\n        // Linear reverse iteration until the first matching item index is found.\n        for (let i = mid - 1; i >= 0; i--) {\n          if (compareFunction(array[i], element) === 0) {\n            continue;\n          }\n          return i + 1;\n        }\n        return 0;\n      } /* Else look in left or right half accordingly */else if (ordering < 0) {\n        start = mid + 1;\n      } else {\n        end = mid - 1;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * binarySearch\n   * @desc Returns the first index of which given item is found in array using binary search.\n   * @param {Buffer[]} array - Array of items.\n   * @param {Buffer} element - Item to find.\n   * @param {Function} compareFunction\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = tree.binarySearch(array, element, Buffer.compare)\n   *```\n   */\n  binarySearch(array, element, compareFunction) {\n    return Base.binarySearch(array, element, compareFunction);\n  }\n\n  /**\n   * linearSearch\n   * @desc Returns the first index of which given item is found in array using linear search.\n   * @param {Buffer[]} array - Array of items.\n   * @param {Buffer} element - Item to find.\n   * @param {Function} eqChecker\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = MerkleTree.linearSearch(array, element, (a, b) => a === b)\n   *```\n   */\n  static linearSearch(array, element, eqChecker) {\n    for (let i = 0; i < array.length; i++) {\n      if (eqChecker(array[i], element)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * linearSearch\n   * @desc Returns the first index of which given item is found in array using linear search.\n   * @param {Buffer[]} array - Array of items.\n   * @param {Buffer} element - Item to find.\n   * @param {Function} eqChecker\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = tree.linearSearch(array, element, (a, b) => a === b)\n   *```\n   */\n  linearSearch(array, element, eqChecker) {\n    return Base.linearSearch(array, element, eqChecker);\n  }\n\n  /**\n   * bufferify\n   * @desc Returns a buffer type for the given value.\n   * @param {String|Number|Object|Buffer|ArrayBuffer} value\n   * @return {Buffer}\n   *\n   * @example\n   * ```js\n   *const buf = MerkleTree.bufferify('0x1234')\n   *```\n   */\n  static bufferify(value) {\n    if (!Buffer.isBuffer(value)) {\n      // crypto-js support\n      if (typeof value === \"object\" && value.words) {\n        return Buffer.from(value.toString(convertWordsToBuffer), \"hex\");\n      } else if (Base.isHexString(value)) {\n        return Buffer.from(value.replace(/^0x/, \"\"), \"hex\");\n      } else if (typeof value === \"string\") {\n        return Buffer.from(value);\n      } else if (typeof value === \"bigint\") {\n        return Buffer.from(value.toString(16), \"hex\");\n      } else if (value instanceof Uint8Array) {\n        return Buffer.from(value.buffer);\n      } else if (typeof value === \"number\") {\n        let s = value.toString();\n        if (s.length % 2) {\n          s = `0${s}`;\n        }\n        return Buffer.from(s, \"hex\");\n      } else if (ArrayBuffer.isView(value)) {\n        return Buffer.from(value.buffer, value.byteOffset, value.byteLength);\n      }\n    }\n    return value;\n  }\n  bigNumberify(value) {\n    return Base.bigNumberify(value);\n  }\n  static bigNumberify(value) {\n    if (typeof value === \"bigint\") {\n      return value;\n    }\n    if (typeof value === \"string\") {\n      if (value.startsWith(\"0x\") && Base.isHexString(value)) {\n        return BigInt(\"0x\" + value.replace(\"0x\", \"\").toString());\n      }\n      return BigInt(value);\n    }\n    if (Buffer.isBuffer(value)) {\n      return BigInt(\"0x\" + value.toString(\"hex\"));\n    }\n    if (value instanceof Uint8Array) {\n      return uint8ArrayToBigInt(value);\n    }\n    if (typeof value === \"number\") {\n      return BigInt(value);\n    }\n    throw new Error(\"cannot bigNumberify\");\n  }\n\n  /**\n   * isHexString\n   * @desc Returns true if value is a hex string.\n   * @param {String} value\n   * @return {Boolean}\n   *\n   * @example\n   * ```js\n   *console.log(MerkleTree.isHexString('0x1234'))\n   *```\n   */\n  static isHexString(v) {\n    return typeof v === \"string\" && /^(0x)?[0-9A-Fa-f]*$/.test(v);\n  }\n\n  /**\n   * print\n   * @desc Prints out a visual representation of the given merkle tree.\n   * @param {Object} tree - Merkle tree instance.\n   * @return {String}\n   * @example\n   *```js\n   *MerkleTree.print(tree)\n   *```\n   */\n  static print(tree) {\n    console.log(tree.toString());\n  }\n\n  /**\n   * bufferToHex\n   * @desc Returns a hex string with 0x prefix for given buffer.\n   * @param {Buffer} value\n   * @return {String}\n   * @example\n   *```js\n   *const hexStr = tree.bufferToHex(Buffer.from('A'))\n   *```\n   */\n  bufferToHex(value) {\n    let withPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return Base.bufferToHex(value, withPrefix);\n  }\n\n  /**\n   * bufferToHex\n   * @desc Returns a hex string with 0x prefix for given buffer.\n   * @param {Buffer} value\n   * @return {String}\n   * @example\n   *```js\n   *const hexStr = MerkleTree.bufferToHex(Buffer.from('A'))\n   *```\n   */\n  static bufferToHex(value) {\n    let withPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return `${withPrefix ? \"0x\" : \"\"}${(value || Buffer.alloc(0)).toString(\"hex\")}`;\n  }\n\n  /**\n   * bufferify\n   * @desc Returns a buffer type for the given value.\n   * @param {String|Number|Object|Buffer} value\n   * @return {Buffer}\n   *\n   * @example\n   * ```js\n   *const buf = tree.bufferify('0x1234')\n   *```\n   */\n  bufferify(value) {\n    return Base.bufferify(value);\n  }\n\n  /**\n   * bufferifyFn\n   * @desc Returns a function that will bufferify the return value.\n   * @param {Function}\n   * @return {Function}\n   *\n   * @example\n   * ```js\n   *const fn = tree.bufferifyFn((value) => sha256(value))\n   *```\n   */\n  bufferifyFn(f) {\n    return value => {\n      const v = f(value);\n      if (Buffer.isBuffer(v)) {\n        return v;\n      }\n      if (this.isHexString(v)) {\n        return Buffer.from(v.replace(\"0x\", \"\"), \"hex\");\n      }\n      if (typeof v === \"string\") {\n        return Buffer.from(v);\n      }\n      if (typeof v === \"bigint\") {\n        return Buffer.from(value.toString(16), \"hex\");\n      }\n      if (ArrayBuffer.isView(v)) {\n        return Buffer.from(v.buffer, v.byteOffset, v.byteLength);\n      }\n\n      // crypto-js support\n      const arrayBuffer = hexStringToArrayBuffer(value.toString(\"hex\"));\n      // Assuming f now works with ArrayBuffers\n      const processedBuffer = f(arrayBuffer);\n      const hexResult = arrayBufferToHexString(processedBuffer);\n      return Buffer.from(hexResult, \"hex\");\n    };\n  }\n\n  /**\n   * isHexString\n   * @desc Returns true if value is a hex string.\n   * @param {String} value\n   * @return {Boolean}\n   *\n   * @example\n   * ```js\n   *console.log(MerkleTree.isHexString('0x1234'))\n   *```\n   */\n  isHexString(value) {\n    return Base.isHexString(value);\n  }\n\n  /**\n   * log2\n   * @desc Returns the log2 of number.\n   * @param {Number} value\n   * @return {Number}\n   */\n  log2(n) {\n    return n === 1 ? 0 : 1 + this.log2(n / 2 | 0);\n  }\n\n  /**\n   * zip\n   * @desc Returns true if value is a hex string.\n   * @param {String[]|Number[]|Buffer[]} a - first array\n   * @param {String[]|Number[]|Buffer[]} b -  second array\n   * @return {String[][]|Number[][]|Buffer[][]}\n   *\n   * @example\n   * ```js\n   *const zipped = tree.zip(['a', 'b'],['A', 'B'])\n   *console.log(zipped) // [ [ 'a', 'A' ], [ 'b', 'B' ] ]\n   *```\n   */\n  zip(a, b) {\n    return a.map((e, i) => [e, b[i]]);\n  }\n  static hexZeroPad(hexStr, length) {\n    return \"0x\" + hexStr.replace(\"0x\", \"\").padStart(length, \"0\");\n  }\n}\nvar Base$1 = Base;\n\n// UTILS\n\n// replaces CryptoJS.enc.Hex\nfunction convertWordsToBuffer(value) {\n  const wordArray = value.words;\n  const arrayBuffer = new ArrayBuffer(wordArray.length * 4); // 4 bytes per word\n  const uint8View = new Uint8Array(arrayBuffer);\n  for (let i = 0; i < wordArray.length; i++) {\n    uint8View[i * 4] = wordArray[i] >> 24 & 0xff;\n    uint8View[i * 4 + 1] = wordArray[i] >> 16 & 0xff;\n    uint8View[i * 4 + 2] = wordArray[i] >> 8 & 0xff;\n    uint8View[i * 4 + 3] = wordArray[i] & 0xff;\n  }\n  return arrayBuffer;\n}\nfunction hexStringToArrayBuffer(hexString) {\n  const buffer = new Uint8Array(hexString.length / 2);\n  for (let i = 0; i < hexString.length; i += 2) {\n    buffer[i / 2] = parseInt(hexString.substring(i, i + 2), 16);\n  }\n  return buffer.buffer;\n}\nfunction arrayBufferToHexString(arrayBuffer) {\n  const uint8View = new Uint8Array(arrayBuffer);\n  return Array.from(uint8View).map(byte => byte.toString(16).padStart(2, \"0\")).join(\"\");\n}\nfunction uint8ArrayToBigInt(u8a) {\n  const hex = Array.from(u8a).map(byte => byte.toString(16).padStart(2, \"0\")).join(\"\");\n  return BigInt(`0x${hex}`);\n}\n\n// ADAPTED FROM https://github.com/merkletreejs/merkletreejs\n\n// TODO: Clean up and DRY up code\n// Disclaimer: The multiproof code is unaudited and may possibly contain serious issues. It's in a hacky state as is and needs to be rewritten.\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\nclass MerkleTree extends Base$1 {\n  duplicateOdd = false;\n  concatenator = Buffer.concat;\n  hashLeaves = false;\n  isBitcoinTree = false;\n  leaves = [];\n  layers = [];\n  sortLeaves = false;\n  sortPairs = false;\n  sort = false;\n  fillDefaultHash = null;\n  complete = false;\n\n  /**\n   * @desc Constructs a Merkle Tree.\n   * All nodes and leaves are stored as Buffers.\n   * Lonely leaf nodes are promoted to the next level up without being hashed again.\n   * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.\n   * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes\n   * @param {Object} options - Additional options\n   * @example\n   *```js\n   *const MerkleTree = require('merkletreejs')\n   *const crypto = require('crypto')\n   *\n   *function sha256(data) {\n   *  // returns Buffer\n   *  return crypto.createHash('sha256').update(data).digest()\n   *}\n   *\n   *const leaves = ['a', 'b', 'c'].map(value => keccak(value))\n   *\n   *const tree = new MerkleTree(leaves, sha256)\n   *```\n   */\n  constructor(leaves, hashFn) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    if (options.complete) {\n      if (options.isBitcoinTree) {\n        throw new Error('option \"complete\" is incompatible with \"isBitcoinTree\"');\n      }\n      if (options.duplicateOdd) {\n        throw new Error('option \"complete\" is incompatible with \"duplicateOdd\"');\n      }\n    }\n    this.isBitcoinTree = !!options.isBitcoinTree;\n    this.hashLeaves = !!options.hashLeaves;\n    this.sortLeaves = !!options.sortLeaves;\n    this.sortPairs = !!options.sortPairs;\n    this.complete = !!options.complete;\n    if (options.fillDefaultHash) {\n      if (typeof options.fillDefaultHash === \"function\") {\n        this.fillDefaultHash = options.fillDefaultHash;\n      } else if (Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === \"string\") {\n        this.fillDefaultHash = (idx, hashFn) => options.fillDefaultHash;\n      } else {\n        throw new Error('method \"fillDefaultHash\" must be a function, Buffer, or string');\n      }\n    }\n    this.sort = !!options.sort;\n    if (this.sort) {\n      this.sortLeaves = true;\n      this.sortPairs = true;\n    }\n    this.duplicateOdd = !!options.duplicateOdd;\n    if (options.concatenator) {\n      this.concatenator = options.concatenator;\n    }\n    this.hashFn = this.bufferifyFn(hashFn);\n    this.processLeaves(leaves);\n  }\n  getOptions() {\n    return {\n      complete: this.complete,\n      isBitcoinTree: this.isBitcoinTree,\n      hashLeaves: this.hashLeaves,\n      sortLeaves: this.sortLeaves,\n      sortPairs: this.sortPairs,\n      sort: this.sort,\n      fillDefaultHash: this.fillDefaultHash?.toString() ?? null,\n      duplicateOdd: this.duplicateOdd\n    };\n  }\n  processLeaves(leaves) {\n    if (this.hashLeaves) {\n      leaves = leaves.map(this.hashFn);\n    }\n    this.leaves = leaves.map(this.bufferify);\n    if (this.sortLeaves) {\n      this.leaves = this.leaves.sort(Buffer.compare);\n    }\n    if (this.fillDefaultHash) {\n      for (let i = this.leaves.length; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++) {\n        this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));\n      }\n    }\n    this.createHashes(this.leaves);\n  }\n  createHashes(nodes) {\n    this.layers = [nodes];\n    while (nodes.length > 1) {\n      const layerIndex = this.layers.length;\n      this.layers.push([]);\n      const layerLimit = this.complete && layerIndex === 1 && !Number.isInteger(Math.log2(nodes.length)) ? 2 * nodes.length - 2 ** Math.ceil(Math.log2(nodes.length)) : nodes.length;\n      for (let i = 0; i < nodes.length; i += 2) {\n        if (i >= layerLimit) {\n          this.layers[layerIndex].push(...nodes.slice(layerLimit));\n          break;\n        } else if (i + 1 === nodes.length) {\n          if (nodes.length % 2 === 1) {\n            const data = nodes[nodes.length - 1];\n            let hash = data;\n\n            // is bitcoin tree\n            if (this.isBitcoinTree) {\n              // Bitcoin method of duplicating the odd ending nodes\n              hash = this.hashFn(this.concatenator([reverse(data), reverse(data)]));\n              hash = reverse(this.hashFn(hash));\n              this.layers[layerIndex].push(hash);\n              continue;\n            } else {\n              if (this.duplicateOdd) ; else {\n                // push copy of hash and continue iteration\n                this.layers[layerIndex].push(nodes[i]);\n                continue;\n              }\n            }\n          }\n        }\n        const left = nodes[i];\n        const right = i + 1 === nodes.length ? left : nodes[i + 1];\n        let combined = null;\n        if (this.isBitcoinTree) {\n          combined = [reverse(left), reverse(right)];\n        } else {\n          combined = [left, right];\n        }\n        if (this.sortPairs) {\n          combined.sort(Buffer.compare);\n        }\n        let hash = this.hashFn(this.concatenator(combined));\n\n        // double hash if bitcoin tree\n        if (this.isBitcoinTree) {\n          hash = reverse(this.hashFn(hash));\n        }\n        this.layers[layerIndex].push(hash);\n      }\n      nodes = this.layers[layerIndex];\n    }\n  }\n\n  /**\n   * addLeaf\n   * @desc Adds a leaf to the tree and re-calculates layers.\n   * @param {String|Buffer} - Leaf\n   * @param {Boolean} - Set to true if the leaf should be hashed before being added to tree.\n   * @example\n   *```js\n   *tree.addLeaf(newLeaf)\n   *```\n   */\n  addLeaf(leaf) {\n    let shouldHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (shouldHash) {\n      leaf = this.hashFn(leaf);\n    }\n    this.processLeaves(this.leaves.concat(leaf));\n  }\n\n  /**\n   * addLeaves\n   * @desc Adds multiple leaves to the tree and re-calculates layers.\n   * @param {String[]|Buffer[]} - Array of leaves\n   * @param {Boolean} - Set to true if the leaves should be hashed before being added to tree.\n   * @example\n   *```js\n   *tree.addLeaves(newLeaves)\n   *```\n   */\n  addLeaves(leaves) {\n    let shouldHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (shouldHash) {\n      leaves = leaves.map(this.hashFn);\n    }\n    this.processLeaves(this.leaves.concat(leaves));\n  }\n\n  /**\n   * getLeaves\n   * @desc Returns array of leaves of Merkle Tree.\n   * @return {Buffer[]}\n   * @example\n   *```js\n   *const leaves = tree.getLeaves()\n   *```\n   */\n  getLeaves(values) {\n    if (Array.isArray(values)) {\n      if (this.hashLeaves) {\n        values = values.map(this.hashFn);\n        if (this.sortLeaves) {\n          values = values.sort(Buffer.compare);\n        }\n      }\n      return this.leaves.filter(\n      // @ts-expect-error - issue from original code\n      leaf => this.bufferIndexOf(values, leaf, this.sortLeaves) !== -1);\n    }\n    return this.leaves;\n  }\n\n  /**\n   * getLeaf\n   * @desc Returns the leaf at the given index.\n   * @param {Number} - Index number\n   * @return {Buffer}\n   * @example\n   *```js\n   *const leaf = tree.getLeaf(1)\n   *```\n   */\n  getLeaf(index) {\n    if (index < 0 || index > this.leaves.length - 1) {\n      return Buffer.from([]);\n    }\n    return this.leaves[index];\n  }\n\n  /**\n   * getLeafIndex\n   * @desc Returns the index of the given leaf, or -1 if the leaf is not found.\n   * @param {String|Buffer} - Target leaf\n   * @return {number}\n   * @example\n   *```js\n   *const leaf = Buffer.from('abc')\n   *const index = tree.getLeafIndex(leaf)\n   *```\n   */\n  getLeafIndex(target) {\n    target = this.bufferify(target);\n    const leaves = this.getLeaves();\n    for (let i = 0; i < leaves.length; i++) {\n      const leaf = leaves[i];\n      if (leaf.equals(target)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * getLeafCount\n   * @desc Returns the total number of leaves.\n   * @return {number}\n   * @example\n   *```js\n   *const count = tree.getLeafCount()\n   *```\n   */\n  getLeafCount() {\n    return this.leaves.length;\n  }\n\n  /**\n   * getHexLeaves\n   * @desc Returns array of leaves of Merkle Tree as hex strings.\n   * @return {String[]}\n   * @example\n   *```js\n   *const leaves = tree.getHexLeaves()\n   *```\n   */\n  getHexLeaves() {\n    return this.leaves.map(leaf => this.bufferToHex(leaf));\n  }\n\n  /**\n   * marshalLeaves\n   * @desc Returns array of leaves of Merkle Tree as a JSON string.\n   * @param {String[]|Buffer[]} - Merkle tree leaves\n   * @return {String} - List of leaves as JSON string\n   * @example\n   *```js\n   *const jsonStr = MerkleTree.marshalLeaves(leaves)\n   *```\n   */\n  static marshalLeaves(leaves) {\n    return JSON.stringify(leaves.map(leaf => MerkleTree.bufferToHex(leaf)), null, 2);\n  }\n\n  /**\n   * unmarshalLeaves\n   * @desc Returns array of leaves of Merkle Tree as a Buffers.\n   * @param {String|Object} - JSON stringified leaves\n   * @return {Buffer[]} - Unmarshalled list of leaves\n   * @example\n   *```js\n   *const leaves = MerkleTree.unmarshalLeaves(jsonStr)\n   *```\n   */\n  static unmarshalLeaves(jsonStr) {\n    let parsed = null;\n    if (typeof jsonStr === \"string\") {\n      parsed = JSON.parse(jsonStr);\n    } else if (jsonStr instanceof Object) {\n      parsed = jsonStr;\n    } else {\n      throw new Error(\"Expected type of string or object\");\n    }\n    if (!parsed) {\n      return [];\n    }\n    if (!Array.isArray(parsed)) {\n      throw new Error(\"Expected JSON string to be array\");\n    }\n    return parsed.map(MerkleTree.bufferify);\n  }\n\n  /**\n   * getLayers\n   * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.\n   * @return {Buffer[][]}\n   * @example\n   *```js\n   *const layers = tree.getLayers()\n   *```\n   */\n  getLayers() {\n    return this.layers;\n  }\n\n  /**\n   * getHexLayers\n   * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.\n   * @return {String[][]}\n   * @example\n   *```js\n   *const layers = tree.getHexLayers()\n   *```\n   */\n  getHexLayers() {\n    return this.layers.reduce((acc, item) => {\n      if (Array.isArray(item)) {\n        acc.push(item.map(layer => this.bufferToHex(layer)));\n      } else {\n        acc.push(item);\n      }\n      return acc;\n    }, []);\n  }\n\n  /**\n   * getLayersFlat\n   * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.\n   * @return {Buffer[]}\n   * @example\n   *```js\n   *const layers = tree.getLayersFlat()\n   *```\n   */\n  getLayersFlat() {\n    const layers = this.layers.reduce((acc, item) => {\n      if (Array.isArray(item)) {\n        acc.unshift(...item);\n      } else {\n        acc.unshift(item);\n      }\n      return acc;\n    }, []);\n    layers.unshift(Buffer.from([0]));\n    return layers;\n  }\n\n  /**\n   * getHexLayersFlat\n   * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.\n   * @return {String[]}\n   * @example\n   *```js\n   *const layers = tree.getHexLayersFlat()\n   *```\n   */\n  getHexLayersFlat() {\n    return this.getLayersFlat().map(layer => this.bufferToHex(layer));\n  }\n\n  /**\n   * getLayerCount\n   * @desc Returns the total number of layers.\n   * @return {number}\n   * @example\n   *```js\n   *const count = tree.getLayerCount()\n   *```\n   */\n  getLayerCount() {\n    return this.getLayers().length;\n  }\n\n  /**\n   * getRoot\n   * @desc Returns the Merkle root hash as a Buffer.\n   * @return {Buffer}\n   * @example\n   *```js\n   *const root = tree.getRoot()\n   *```\n   */\n  getRoot() {\n    if (this.layers.length === 0) {\n      return Buffer.from([]);\n    }\n    return this.layers[this.layers.length - 1][0] || Buffer.from([]);\n  }\n\n  /**\n   * getHexRoot\n   * @desc Returns the Merkle root hash as a hex string.\n   * @return {String}\n   * @example\n   *```js\n   *const root = tree.getHexRoot()\n   *```\n   */\n  getHexRoot() {\n    return this.bufferToHex(this.getRoot());\n  }\n\n  /**\n   * getProof\n   * @desc Returns the proof for a target leaf.\n   * @param {Buffer} leaf - Target leaf\n   * @param {Number} [index] - Target leaf index in leaves array.\n   * Use if there are leaves containing duplicate data in order to distinguish it.\n   * @return {Object[]} - Array of objects containing a position property of type string\n   * with values of 'left' or 'right' and a data property of type Buffer.\n   * @example\n   * ```js\n   *const proof = tree.getProof(leaves[2])\n   *```\n   *\n   * @example\n   *```js\n   *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n   *const tree = new MerkleTree(leaves, keccak)\n   *const proof = tree.getProof(leaves[2], 2)\n   *```\n   */\n  getProof(leaf, index) {\n    if (typeof leaf === \"undefined\") {\n      throw new Error(\"leaf is required\");\n    }\n    leaf = this.bufferify(leaf);\n    const proof = [];\n    if (!Number.isInteger(index)) {\n      index = -1;\n      for (let i = 0; i < this.leaves.length; i++) {\n        if (Buffer.compare(leaf, this.leaves[i]) === 0) {\n          index = i;\n        }\n      }\n    }\n\n    // @ts-expect-error - issue from original code\n    if (index <= -1) {\n      return [];\n    }\n    for (let i = 0; i < this.layers.length; i++) {\n      const layer = this.layers[i];\n      // @ts-expect-error - issue from original code\n      const isRightNode = index % 2;\n      const pairIndex = isRightNode ?\n      // @ts-expect-error - issue from original code\n      index - 1 : this.isBitcoinTree && index === layer.length - 1 && i < this.layers.length - 1 ?\n      // Proof Generation for Bitcoin Trees\n      index :\n      // Proof Generation for Non-Bitcoin Trees\n      // @ts-expect-error - issue from original code\n      index + 1;\n      if (pairIndex < layer.length) {\n        proof.push({\n          position: isRightNode ? \"left\" : \"right\",\n          data: layer[pairIndex]\n        });\n      }\n\n      // set index to parent index\n      // @ts-expect-error - issue from original code\n      index = index / 2 | 0;\n    }\n\n    // @ts-expect-error - issue from original code\n    return proof;\n  }\n\n  /**\n   * getHexProof\n   * @desc Returns the proof for a target leaf as hex strings.\n   * @param {Buffer} leaf - Target leaf\n   * @param {Number} [index] - Target leaf index in leaves array.\n   * Use if there are leaves containing duplicate data in order to distinguish it.\n   * @return {String[]} - Proof array as hex strings.\n   * @example\n   * ```js\n   *const proof = tree.getHexProof(leaves[2])\n   *```\n   */\n  getHexProof(leaf, index) {\n    return this.getProof(leaf, index).map(item => this.bufferToHex(item.data));\n  }\n\n  /**\n   * getProofs\n   * @desc Returns the proofs for all leaves.\n   * @return {Object[]} - Array of objects containing a position property of type string\n   * with values of 'left' or 'right' and a data property of type Buffer for all leaves.\n   * @example\n   * ```js\n   *const proofs = tree.getProofs()\n   *```\n   *\n   * @example\n   *```js\n   *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n   *const tree = new MerkleTree(leaves, keccak)\n   *const proofs = tree.getProofs()\n   *```\n   */\n  getProofs() {\n    // @ts-expect-error - issue from original code\n    const proof = [];\n    // @ts-expect-error - issue from original code\n    const proofs = [];\n\n    // @ts-expect-error - issue from original code\n    this.getProofsDFS(this.layers.length - 1, 0, proof, proofs);\n\n    // @ts-expect-error - issue from original code\n    return proofs;\n  }\n\n  /**\n   * getProofsDFS\n   * @desc Get all proofs through single traverse\n   * @param {Number} currentLayer - Current layer index in traverse.\n   * @param {Number} index - Current tarvese node index in traverse.\n   * @param {Object[]} proof - Proof chain for single leaf.\n   * @param {Object[]} proofs - Proofs for all leaves\n   * @example\n   * ```js\n   *const layers = tree.getLayers()\n   *const index = 0;\n   *let proof = [];\n   *let proofs = [];\n   *const proof = tree.getProofsDFS(layers, index, proof, proofs)\n   *```\n   */\n  // @ts-expect-error - issue from original code\n  getProofsDFS(currentLayer, index, proof, proofs) {\n    const isRightNode = index % 2;\n    if (currentLayer === -1) {\n      if (!isRightNode) {\n        proofs.push([...proof].reverse());\n      }\n      // @ts-expect-error - issue from original code\n      return;\n    }\n    if (index >= this.layers[currentLayer].length) {\n      // @ts-expect-error - issue from original code\n      return;\n    }\n    const layer = this.layers[currentLayer];\n    const pairIndex = isRightNode ? index - 1 : index + 1;\n    let pushed = false;\n    if (pairIndex < layer.length) {\n      pushed = true;\n      proof.push({\n        position: isRightNode ? \"left\" : \"right\",\n        data: layer[pairIndex]\n      });\n    }\n    const leftchildIndex = index * 2;\n    const rightchildIndex = index * 2 + 1;\n    this.getProofsDFS(currentLayer - 1, leftchildIndex, proof, proofs);\n    this.getProofsDFS(currentLayer - 1, rightchildIndex, proof, proofs);\n    if (pushed) {\n      proof.splice(proof.length - 1, 1);\n    }\n  }\n\n  /**\n   * getHexProofs\n   * @desc Returns the proofs for all leaves as hex strings.\n   * @return {String[]} - Proofs array as hex strings.\n   * @example\n   * ```js\n   *const proofs = tree.getHexProofs()\n   *```\n   */\n  getHexProofs() {\n    return this.getProofs().map(item => this.bufferToHex(item.data));\n  }\n\n  /**\n   * getPositionalHexProof\n   * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).\n   * @param {Buffer} leaf - Target leaf\n   * @param {Number} [index] - Target leaf index in leaves array.\n   * Use if there are leaves containing duplicate data in order to distinguish it.\n   * @return {(string | number)[][]} - Proof array as hex strings. position at index 0\n   * @example\n   * ```js\n   *const proof = tree.getPositionalHexProof(leaves[2])\n   *```\n   */\n  getPositionalHexProof(leaf, index) {\n    return this.getProof(leaf, index).map(item => {\n      return [item.position === \"left\" ? 0 : 1, this.bufferToHex(item.data)];\n    });\n  }\n\n  /**\n   * getProofIndices\n   * @desc Returns the proof indices for given tree indices.\n   * @param {Number[]} treeIndices - Tree indices\n   * @param {Number} depth - Tree depth; number of layers.\n   * @return {Number[]} - Proof indices\n   * @example\n   * ```js\n   *const proofIndices = tree.getProofIndices([2,5,6], 4)\n   *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]\n   *```\n   */\n  getProofIndices(treeIndices, depth) {\n    const leafCount = 2 ** depth;\n    let maximalIndices = new Set();\n    for (const index of treeIndices) {\n      let x = leafCount + index;\n      while (x > 1) {\n        maximalIndices.add(x ^ 1);\n        x = x / 2 | 0;\n      }\n    }\n    const a = treeIndices.map(index => leafCount + index);\n    const b = Array.from(maximalIndices).sort((x, y) => x - y).reverse();\n    maximalIndices = a.concat(b);\n    const redundantIndices = new Set();\n    const proof = [];\n    for (let index of maximalIndices) {\n      if (!redundantIndices.has(index)) {\n        proof.push(index);\n        while (index > 1) {\n          redundantIndices.add(index);\n          if (!redundantIndices.has(index ^ 1)) {\n            break;\n          }\n          index = index / 2 | 0;\n        }\n      }\n    }\n    return proof.filter(index => {\n      return !treeIndices.includes(index - leafCount);\n    });\n  }\n  getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {\n    const depth = Math.ceil(Math.log2(leavesCount));\n    const unevenLayers = [];\n    for (let index = 0; index < depth; index++) {\n      const unevenLayer = leavesCount % 2 !== 0;\n      if (unevenLayer) {\n        unevenLayers.push({\n          index,\n          leavesCount\n        });\n      }\n      leavesCount = Math.ceil(leavesCount / 2);\n    }\n    const proofIndices = [];\n    let layerNodes = sortedLeafIndices;\n    for (let layerIndex = 0; layerIndex < depth; layerIndex++) {\n      const siblingIndices = layerNodes.map(index => {\n        if (index % 2 === 0) {\n          return index + 1;\n        }\n        return index - 1;\n      });\n      let proofNodeIndices = siblingIndices.filter(index => !layerNodes.includes(index));\n      const unevenLayer = unevenLayers.find(_ref => {\n        let {\n          index\n        } = _ref;\n        return index === layerIndex;\n      });\n      if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {\n        proofNodeIndices = proofNodeIndices.slice(0, -1);\n      }\n      proofIndices.push(proofNodeIndices);\n      layerNodes = [...new Set(layerNodes.map(index => {\n        if (index % 2 === 0) {\n          return index / 2;\n        }\n        if (index % 2 === 0) {\n          return (index + 1) / 2;\n        }\n        return (index - 1) / 2;\n      }))];\n    }\n    return proofIndices;\n  }\n\n  /**\n   * getMultiProof\n   * @desc Returns the multiproof for given tree indices.\n   * @param {Number[]} indices - Tree indices.\n   * @return {Buffer[]} - Multiproofs\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getMultiProof(indices)\n   *```\n   */\n  getMultiProof(tree, indices) {\n    if (!this.complete) {\n      console.warn(\"Warning: For correct multiProofs it's strongly recommended to set complete: true\");\n    }\n    if (!indices) {\n      indices = tree;\n      tree = this.getLayersFlat();\n    }\n    const isUneven = this.isUnevenTree();\n    if (isUneven) {\n      // @ts-expect-error - issue from original code\n      if (indices.every(Number.isInteger)) {\n        return this.getMultiProofForUnevenTree(indices);\n      }\n    }\n    // @ts-expect-error - issue from original code\n    if (!indices.every(Number.isInteger)) {\n      let els = indices;\n      if (this.sortPairs) {\n        // @ts-expect-error - issue from original code\n        els = els.sort(Buffer.compare);\n      }\n\n      // @ts-expect-error - issue from original code\n      let ids = els.map(el => this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n      if (!ids.every(idx => idx !== -1)) {\n        throw new Error(\"Element does not exist in Merkle tree\");\n      }\n\n      // @ts-expect-error - issue from original code\n      const hashes = [];\n      const proof = [];\n      let nextIds = [];\n      for (let i = 0; i < this.layers.length; i++) {\n        const layer = this.layers[i];\n        for (let j = 0; j < ids.length; j++) {\n          const idx = ids[j];\n          const pairElement = this.getPairNode(layer, idx);\n          hashes.push(layer[idx]);\n          if (pairElement) {\n            proof.push(pairElement);\n          }\n          nextIds.push(idx / 2 | 0);\n        }\n        ids = nextIds.filter((value, j, self) => self.indexOf(value) === j);\n        nextIds = [];\n      }\n\n      // @ts-expect-error - issue from original code\n      return proof.filter(value => !hashes.includes(value));\n    }\n\n    // @ts-expect-error - issue from original code\n    return this.getProofIndices(indices, Math.log2(tree.length / 2 | 0)).map(\n    // @ts-expect-error - issue from original code\n    index => tree[index]);\n  }\n  getMultiProofForUnevenTree(tree, indices) {\n    if (!indices) {\n      indices = tree;\n      tree = this.getLayers();\n    }\n    let proofHashes = [];\n    // @ts-expect-error - issue from original code\n    let currentLayerIndices = indices;\n    // @ts-expect-error - issue from original code\n    for (const treeLayer of tree) {\n      const siblings = [];\n      for (const index of currentLayerIndices) {\n        if (index % 2 === 0) {\n          const idx = index + 1;\n          if (!currentLayerIndices.includes(idx)) {\n            if (treeLayer[idx]) {\n              siblings.push(treeLayer[idx]);\n              continue;\n            }\n          }\n        }\n        const idx = index - 1;\n        if (!currentLayerIndices.includes(idx)) {\n          if (treeLayer[idx]) {\n            siblings.push(treeLayer[idx]);\n            continue;\n          }\n        }\n      }\n      proofHashes = proofHashes.concat(siblings);\n      const uniqueIndices = new Set();\n      for (const index of currentLayerIndices) {\n        if (index % 2 === 0) {\n          uniqueIndices.add(index / 2);\n          continue;\n        }\n        if (index % 2 === 0) {\n          uniqueIndices.add((index + 1) / 2);\n          continue;\n        }\n        uniqueIndices.add((index - 1) / 2);\n      }\n      currentLayerIndices = Array.from(uniqueIndices);\n    }\n    return proofHashes;\n  }\n\n  /**\n   * getHexMultiProof\n   * @desc Returns the multiproof for given tree indices as hex strings.\n   * @param {Number[]} indices - Tree indices.\n   * @return {String[]} - Multiproofs as hex strings.\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getHexMultiProof(indices)\n   *```\n   */\n  getHexMultiProof(tree, indices) {\n    return this.getMultiProof(tree, indices).map(x => this.bufferToHex(x));\n  }\n\n  /**\n   * getProofFlags\n   * @desc Returns list of booleans where proofs should be used instead of hashing.\n   * Proof flags are used in the Solidity multiproof verifiers.\n   * @param {Number[]|Buffer[]} leaves\n   * @param {Buffer[]} proofs\n   * @return {Boolean[]} - Boolean flags\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getMultiProof(indices)\n   *const proofFlags = tree.getProofFlags(leaves, proof)\n   *```\n   */\n  getProofFlags(leaves, proofs) {\n    if (!Array.isArray(leaves) || leaves.length <= 0) {\n      throw new Error(\"Invalid Inputs!\");\n    }\n    let ids;\n    if (leaves.every(Number.isInteger)) {\n      ids = [...leaves].sort((a, b) => a === b ? 0 : a > b ? 1 : -1); // Indices where passed\n    } else {\n      ids = leaves.map(el => this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n    }\n    if (!ids.every(idx => idx !== -1)) {\n      throw new Error(\"Element does not exist in Merkle tree\");\n    }\n    const _proofs = proofs.map(item => this.bufferify(item));\n\n    // @ts-expect-error - issue from original code\n    const tested = [];\n    // @ts-expect-error - issue from original code\n    const flags = [];\n    for (let index = 0; index < this.layers.length; index++) {\n      const layer = this.layers[index];\n      ids = ids.reduce((ids_, idx) => {\n        // @ts-expect-error - issue from original code\n        const skipped = tested.includes(layer[idx]);\n        if (!skipped) {\n          const pairElement = this.getPairNode(layer, idx);\n          const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);\n          // eslint-disable-next-line no-unused-expressions\n          pairElement && flags.push(!proofUsed);\n          tested.push(layer[idx]);\n          tested.push(pairElement);\n        }\n        // @ts-expect-error - issue from original code\n        ids_.push(idx / 2 | 0);\n        return ids_;\n      }, []);\n    }\n\n    // @ts-expect-error - issue from original code\n    return flags;\n  }\n\n  /**\n   * verify\n   * @desc Returns true if the proof path (array of hashes) can connect the target node\n   * to the Merkle root.\n   * @param {Object[]} proof - Array of proof objects that should connect\n   * target node to Merkle root.\n   * @param {Buffer} targetNode - Target node Buffer\n   * @param {Buffer} root - Merkle root Buffer\n   * @return {Boolean}\n   * @example\n   *```js\n   *const root = tree.getRoot()\n   *const proof = tree.getProof(leaves[2])\n   *const verified = tree.verify(proof, leaves[2], root)\n   *```\n   */\n  verify(proof, targetNode, root) {\n    let hash = this.bufferify(targetNode);\n    root = this.bufferify(root);\n    if (!Array.isArray(proof) || !targetNode || !root) {\n      return false;\n    }\n    for (let i = 0; i < proof.length; i++) {\n      const node = proof[i];\n      let data = null;\n      let isLeftNode = null;\n\n      // case for when proof is hex values only\n      if (typeof node === \"string\") {\n        data = this.bufferify(node);\n        isLeftNode = true;\n      } else if (Array.isArray(node)) {\n        isLeftNode = node[0] === 0;\n        data = this.bufferify(node[1]);\n      } else if (Buffer.isBuffer(node)) {\n        data = node;\n        isLeftNode = true;\n      } else if (node instanceof Object) {\n        data = this.bufferify(node.data);\n        isLeftNode = node.position === \"left\";\n      } else {\n        throw new Error(\"Expected node to be of type string or object\");\n      }\n      const buffers = [];\n      if (this.isBitcoinTree) {\n        buffers.push(reverse(hash));\n        buffers[isLeftNode ? \"unshift\" : \"push\"](reverse(data));\n        hash = this.hashFn(this.concatenator(buffers));\n        hash = reverse(this.hashFn(hash));\n      } else {\n        if (this.sortPairs) {\n          if (Buffer.compare(hash, data) === -1) {\n            buffers.push(hash, data);\n            hash = this.hashFn(this.concatenator(buffers));\n          } else {\n            buffers.push(data, hash);\n            hash = this.hashFn(this.concatenator(buffers));\n          }\n        } else {\n          buffers.push(hash);\n          buffers[isLeftNode ? \"unshift\" : \"push\"](data);\n          hash = this.hashFn(this.concatenator(buffers));\n        }\n      }\n    }\n    return Buffer.compare(hash, root) === 0;\n  }\n\n  /**\n   * verifyMultiProof\n   * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.\n   * @param {Buffer} root - Merkle tree root\n   * @param {Number[]} proofIndices - Leave indices for proof\n   * @param {Buffer[]} proofLeaves - Leaf values at indices for proof\n   * @param {Number} leavesCount - Count of original leaves\n   * @param {Buffer[]} proof - Multiproofs given indices\n   * @return {Boolean}\n   * @example\n   *```js\n   *const leaves = tree.getLeaves()\n   *const root = tree.getRoot()\n   *const treeFlat = tree.getLayersFlat()\n   *const leavesCount = leaves.length\n   *const proofIndices = [2, 5, 6]\n   *const proofLeaves = proofIndices.map(i => leaves[i])\n   *const proof = tree.getMultiProof(treeFlat, indices)\n   *const verified = tree.verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof)\n   *```\n   */\n  verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof) {\n    const isUneven = this.isUnevenTree();\n    if (isUneven) {\n      // TODO: combine these functions and simplify\n      return this.verifyMultiProofForUnevenTree(root, proofIndices, proofLeaves, leavesCount, proof);\n    }\n    const depth = Math.ceil(Math.log2(leavesCount));\n    root = this.bufferify(root);\n    proofLeaves = proofLeaves.map(leaf => this.bufferify(leaf));\n    proof = proof.map(leaf => this.bufferify(leaf));\n    const tree = {};\n    for (const [index, leaf] of this.zip(proofIndices, proofLeaves)) {\n      // @ts-expect-error - issue from original code\n      tree[2 ** depth + index] = leaf;\n    }\n    for (const [index, proofitem] of this.zip(this.getProofIndices(proofIndices, depth), proof)) {\n      // @ts-expect-error - issue from original code\n      tree[index] = proofitem;\n    }\n    let indexqueue = Object.keys(tree).map(value => Number(value)).sort((a, b) => a - b);\n    indexqueue = indexqueue.slice(0, indexqueue.length - 1);\n    let i = 0;\n    while (i < indexqueue.length) {\n      const index = indexqueue[i];\n      if (index >= 2 && {}.hasOwnProperty.call(tree, index ^ 1)) {\n        // @ts-expect-error - issue from original code\n        let pair = [tree[index - index % 2], tree[index - index % 2 + 1]];\n        if (this.sortPairs) {\n          pair = pair.sort(Buffer.compare);\n        }\n        const hash = pair[1] ? this.hashFn(this.concatenator(pair)) : pair[0];\n        // @ts-expect-error - issue from original code\n        tree[index / 2 | 0] = hash;\n        indexqueue.push(index / 2 | 0);\n      }\n      i += 1;\n    }\n    return !proofIndices.length ||\n    // @ts-expect-error - issue from original code\n    {}.hasOwnProperty.call(tree, 1) && tree[1].equals(root);\n  }\n  verifyMultiProofWithFlags(root, leaves, proofs, proofFlag) {\n    root = this.bufferify(root);\n    leaves = leaves.map(this.bufferify);\n    proofs = proofs.map(this.bufferify);\n    const leavesLen = leaves.length;\n    const totalHashes = proofFlag.length;\n    const hashes = [];\n    let leafPos = 0;\n    let hashPos = 0;\n    let proofPos = 0;\n    for (let i = 0; i < totalHashes; i++) {\n      const bufA = proofFlag[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proofs[proofPos++];\n      const bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n      const buffers = [bufA, bufB].sort(Buffer.compare);\n      hashes[i] = this.hashFn(this.concatenator(buffers));\n    }\n    return Buffer.compare(hashes[totalHashes - 1], root) === 0;\n  }\n  verifyMultiProofForUnevenTree(root, indices, leaves, leavesCount, proof) {\n    root = this.bufferify(root);\n    leaves = leaves.map(leaf => this.bufferify(leaf));\n    proof = proof.map(leaf => this.bufferify(leaf));\n    const computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);\n    return root.equals(computedRoot);\n  }\n\n  /**\n   * getDepth\n   * @desc Returns the tree depth (number of layers)\n   * @return {Number}\n   * @example\n   *```js\n   *const depth = tree.getDepth()\n   *```\n   */\n  getDepth() {\n    return this.getLayers().length - 1;\n  }\n\n  /**\n   * getLayersAsObject\n   * @desc Returns the layers as nested objects instead of an array.\n   * @example\n   *```js\n   *const layersObj = tree.getLayersAsObject()\n   *```\n   */\n  getLayersAsObject() {\n    const layers = this.getLayers().map(layer => layer.map(value => this.bufferToHex(value, false)));\n    const objs = [];\n    for (let i = 0; i < layers.length; i++) {\n      const arr = [];\n      for (let j = 0; j < layers[i].length; j++) {\n        const obj = {\n          [layers[i][j]]: null\n        };\n        if (objs.length) {\n          // @ts-expect-error - issue from original code\n          obj[layers[i][j]] = {};\n          const a = objs.shift();\n          // @ts-expect-error - issue from original code\n          const akey = Object.keys(a)[0];\n          // @ts-expect-error - issue from original code\n          obj[layers[i][j]][akey] = a[akey];\n          if (objs.length) {\n            const b = objs.shift();\n            // @ts-expect-error - issue from original code\n            const bkey = Object.keys(b)[0];\n            // @ts-expect-error - issue from original code\n            obj[layers[i][j]][bkey] = b[bkey];\n          }\n        }\n        arr.push(obj);\n      }\n      objs.push(...arr);\n    }\n    return objs[0];\n  }\n\n  /**\n   * resetTree\n   * @desc Resets the tree by clearing the leaves and layers.\n   * @example\n   *```js\n   *tree.resetTree()\n   *```\n   */\n  resetTree() {\n    this.leaves = [];\n    this.layers = [];\n  }\n\n  /**\n   * getPairNode\n   * @desc Returns the node at the index for given layer.\n   * @param {Buffer[]} layer - Tree layer\n   * @param {Number} index - Index at layer.\n   * @return {Buffer} - Node\n   *\n   *@example\n   * ```js\n   *const node = tree.getPairNode(layer, index)\n   *```\n   */\n  getPairNode(layer, idx) {\n    const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;\n    if (pairIdx < layer.length) {\n      return layer[pairIdx];\n    } else {\n      // @ts-expect-error - issue from original code\n      return null;\n    }\n  }\n\n  /**\n   * toTreeString\n   * @desc Returns a visual representation of the merkle tree as a string.\n   * @return {String}\n   * @example\n   *```js\n   *console.log(tree.toTreeString())\n   *```\n   */\n  toTreeString() {\n    const obj = this.getLayersAsObject();\n    return asTree(obj, true, false);\n  }\n\n  /**\n   * toString\n   * @desc Returns a visual representation of the merkle tree as a string.\n   * @example\n   *```js\n   *console.log(tree.toString())\n   *```\n   */\n  toString() {\n    return this.toTreeString();\n  }\n  isUnevenTree(treeLayers) {\n    const depth = treeLayers?.length || this.getDepth();\n    return !this.isPowOf2(depth);\n  }\n  isPowOf2(v) {\n    return v && !(v & v - 1);\n  }\n  calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {\n    const leafTuples = this.zip(leafIndices, leafHashes).sort((_ref2, _ref3) => {\n      let [indexA] = _ref2;\n      let [indexB] = _ref3;\n      return indexA - indexB;\n    });\n    const leafTupleIndices = leafTuples.map(_ref4 => {\n      let [index] = _ref4;\n      return index;\n    });\n    const proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);\n    let nextSliceStart = 0;\n    const proofTuplesByLayers = [];\n    for (let i = 0; i < proofIndices.length; i++) {\n      const indices = proofIndices[i];\n      const sliceStart = nextSliceStart;\n      nextSliceStart += indices.length;\n      proofTuplesByLayers[i] = this.zip(indices, proofHashes.slice(sliceStart, nextSliceStart));\n    }\n    const tree = [leafTuples];\n    for (let layerIndex = 0; layerIndex < proofTuplesByLayers.length; layerIndex++) {\n      const currentLayer = proofTuplesByLayers[layerIndex].concat(tree[layerIndex])\n      // @ts-expect-error - issue from original code\n      .sort((_ref5, _ref6) => {\n        let [indexA] = _ref5;\n        let [indexB] = _ref6;\n        return indexA - indexB;\n      })\n      // @ts-expect-error - issue from original code\n      .map(_ref7 => {\n        let [, hash] = _ref7;\n        return hash;\n      });\n      const s = tree[layerIndex].map(_ref8 => {\n        let [layerIndex_] = _ref8;\n        return layerIndex_;\n      });\n      const parentIndices = [...new Set(s.map(index => {\n        if (index % 2 === 0) {\n          return index / 2;\n        }\n        if (index % 2 === 0) {\n          return (index + 1) / 2;\n        }\n        return (index - 1) / 2;\n      }))];\n      const parentLayer = [];\n      for (let i = 0; i < parentIndices.length; i++) {\n        const parentNodeTreeIndex = parentIndices[i];\n        const bufA = currentLayer[i * 2];\n        const bufB = currentLayer[i * 2 + 1];\n        const hash = bufB ? this.hashFn(this.concatenator([bufA, bufB])) : bufA;\n        parentLayer.push([parentNodeTreeIndex, hash]);\n      }\n      tree.push(parentLayer);\n    }\n    return tree[tree.length - 1][0][1];\n  }\n}\n\nexport { MerkleTree };\n","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","import { constants, utils, BigNumber } from 'ethers';\nimport { bO as SnapshotInputSchema, bP as SnapshotEntryWithProofSchema, bQ as SnapshotSchema, cu as ContractWrapper, b9 as BigNumberSchema, aZ as NATIVE_TOKEN_ADDRESS, cz as AmountSchema, cD as QuantitySchema, ba as BigNumberishSchema, cE as BytesLikeSchema, s as DuplicateLeafsError, bd as AddressOrEnsSchema, bc as AddressSchema, cF as BasisPointsSchema } from './index-827e427d.browser.esm.js';\nimport { f as fetchCurrencyMetadata, i as isNativeToken, a as fetchCurrencyValue } from './fetchCurrencyValue-39f97190.browser.esm.js';\nimport { n as normalizePriceValue } from './normalizePriceValue-3b8bca4f.browser.esm.js';\nimport { MerkleTree } from '@thirdweb-dev/merkletree';\nimport { S as StartDateSchema, E as EndDateSchema } from './assertEnabled-ea837eec.browser.esm.js';\nimport { z } from 'zod';\nimport { N as NFTInputOrUriSchema } from './setErc20Allowance-7df9a12a.browser.esm.js';\nimport { v4 } from 'uuid';\n\nfunction abstractContractModelToLegacy(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot,\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    quantityLimitPerTransaction: model.maxClaimablePerWallet,\n    waitTimeInSecondsBetweenClaims: model.waitTimeInSecondsBetweenClaims || 0\n  };\n}\n\nfunction abstractContractModelToNew(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot,\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    quantityLimitPerWallet: model.maxClaimablePerWallet,\n    metadata: model.metadata || \"\"\n  };\n}\n\n/**\n * @internal\n * @param quantity - The quantity to convert\n * @param tokenDecimals - The token decimals to use\n */\nfunction convertQuantityToBigNumber(quantity, tokenDecimals) {\n  if (quantity === \"unlimited\") {\n    return constants.MaxUint256;\n  } else {\n    return utils.parseUnits(quantity, tokenDecimals);\n  }\n}\n\nasync function parseSnapshotInputs(inputs) {\n  const chunkSize = 25000;\n  const chunks = Array.from({\n    length: Math.ceil(inputs.length / chunkSize)\n  }, (_, i) => inputs.slice(i * chunkSize, i * chunkSize + chunkSize));\n  const results = [];\n  const parsedChunks = await Promise.all(chunks.map(chunk => SnapshotInputSchema.parseAsync(chunk)));\n  for (const chunk of parsedChunks) {\n    results.push(...chunk);\n  }\n  return results;\n}\n\n// shard using the first 2 hex character of the address\n// this splits the merkle tree into 256 shards\n// shard files will be 00.json, 01.json, 02.json, ..., ff.json\nconst SHARD_NYBBLES = 2;\nlet SnapshotFormatVersion = /*#__PURE__*/function (SnapshotFormatVersion) {\n  SnapshotFormatVersion[SnapshotFormatVersion[\"V1\"] = 1] = \"V1\";\n  SnapshotFormatVersion[SnapshotFormatVersion[\"V2\"] = 2] = \"V2\";\n  return SnapshotFormatVersion;\n}({}); // address, maxClaimable, price, currencyAddress\nclass ShardedMerkleTree {\n  constructor(storage, baseUri, originalEntriesUri, shardNybbles, tokenDecimals) {\n    this.storage = storage;\n    this.shardNybbles = shardNybbles;\n    this.baseUri = baseUri;\n    this.originalEntriesUri = originalEntriesUri;\n    this.tokenDecimals = tokenDecimals;\n    this.shards = {};\n    this.trees = {};\n  }\n  static async fromUri(uri, storage) {\n    try {\n      const shardedMerkleTreeInfo = await storage.downloadJSON(uri);\n      if (shardedMerkleTreeInfo.isShardedMerkleTree) {\n        return ShardedMerkleTree.fromShardedMerkleTreeInfo(shardedMerkleTreeInfo, storage);\n      }\n    } catch (e) {\n      return undefined;\n    }\n  }\n  static async fromShardedMerkleTreeInfo(info, storage) {\n    return new ShardedMerkleTree(storage, info.baseUri, info.originalEntriesUri, info.shardNybbles, info.tokenDecimals);\n  }\n  static hashEntry(entry, tokenDecimals, currencyDecimals, snapshotFormatVersion) {\n    switch (snapshotFormatVersion) {\n      case SnapshotFormatVersion.V1:\n        return utils.solidityKeccak256([\"address\", \"uint256\"], [entry.address, convertQuantityToBigNumber(entry.maxClaimable, tokenDecimals)]);\n      case SnapshotFormatVersion.V2:\n        return utils.solidityKeccak256([\"address\", \"uint256\", \"uint256\", \"address\"], [entry.address, convertQuantityToBigNumber(entry.maxClaimable, tokenDecimals), convertQuantityToBigNumber(entry.price || \"unlimited\", currencyDecimals), entry.currencyAddress || constants.AddressZero]);\n    }\n  }\n  static async fetchAndCacheDecimals(cache, provider, currencyAddress) {\n    if (!currencyAddress) {\n      return 18;\n    }\n    // cache decimals for each currency to avoid refetching for every address\n    let currencyDecimals = cache[currencyAddress];\n    if (currencyDecimals === undefined) {\n      const currencyMetadata = await fetchCurrencyMetadata(provider, currencyAddress);\n      currencyDecimals = currencyMetadata.decimals;\n      cache[currencyAddress] = currencyDecimals;\n    }\n    return currencyDecimals;\n  }\n  static async buildAndUpload(snapshotInput, tokenDecimals, provider, storage, snapshotFormatVersion) {\n    let shardNybbles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : SHARD_NYBBLES;\n    const inputs = await parseSnapshotInputs(snapshotInput);\n\n    // TODO Could also derive shardNybbles from input size\n    const shards = {};\n    for (const snapshotEntry of inputs) {\n      const shard = snapshotEntry.address.slice(2, 2 + shardNybbles).toLowerCase();\n      if (shards[shard] === undefined) {\n        shards[shard] = [];\n      }\n      shards[shard].push(snapshotEntry);\n    }\n    const currencyDecimalMap = {};\n    // create shard => subtree root map\n    const subTrees = await Promise.all(Object.entries(shards).map(async _ref => {\n      let [shard, entries] = _ref;\n      return [shard, new MerkleTree(await Promise.all(entries.map(async entry => {\n        // cache decimals for each currency to avoid refetching for every address\n        const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);\n        return ShardedMerkleTree.hashEntry(entry, tokenDecimals, currencyDecimals, snapshotFormatVersion);\n      })), utils.keccak256, {\n        sort: true\n      }).getHexRoot()];\n    }));\n    const roots = Object.fromEntries(subTrees);\n    // create master tree from shard => subtree root map\n    const tree = new MerkleTree(Object.values(roots), utils.keccak256, {\n      sort: true\n    });\n    const shardsToUpload = [];\n    for (const [shardId, entries] of Object.entries(shards)) {\n      const data = {\n        proofs: tree.getProof(roots[shardId]).map(value => \"0x\" + value.data.toString(\"hex\")),\n        entries\n      };\n      shardsToUpload.push({\n        data: JSON.stringify(data),\n        name: `${shardId}.json`\n      });\n    }\n    const uris = await storage.uploadBatch(shardsToUpload);\n    const baseUri = uris[0].slice(0, uris[0].lastIndexOf(\"/\"));\n    const originalEntriesUri = await storage.upload(inputs);\n    const shardedMerkleInfo = {\n      merkleRoot: tree.getHexRoot(),\n      baseUri,\n      originalEntriesUri,\n      shardNybbles,\n      tokenDecimals,\n      isShardedMerkleTree: true\n    };\n    const masterUri = await storage.upload(shardedMerkleInfo);\n    return {\n      shardedMerkleInfo,\n      uri: masterUri\n    };\n  }\n  async getProof(address, provider, snapshotFormatVersion) {\n    const shardId = address.slice(2, 2 + this.shardNybbles).toLowerCase();\n    let shard = this.shards[shardId];\n    const currencyDecimalMap = {};\n    if (shard === undefined) {\n      try {\n        const uri = this.baseUri.endsWith(\"/\") ? this.baseUri : `${this.baseUri}/`;\n        shard = this.shards[shardId] = await this.storage.downloadJSON(`${uri}${shardId}.json`);\n        const hashedEntries = await Promise.all(shard.entries.map(async entry => {\n          // cache decimals for each currency to avoid refetching for every address\n          const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);\n          return ShardedMerkleTree.hashEntry(entry, this.tokenDecimals, currencyDecimals, snapshotFormatVersion);\n        }));\n        this.trees[shardId] = new MerkleTree(hashedEntries, utils.keccak256, {\n          sort: true\n        });\n      } catch (e) {\n        return null;\n      }\n    }\n    const entry = shard.entries.find(i => i.address.toLowerCase() === address.toLowerCase());\n    if (!entry) {\n      return null;\n    }\n    const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);\n    const leaf = ShardedMerkleTree.hashEntry(entry, this.tokenDecimals, currencyDecimals, snapshotFormatVersion);\n    const proof = this.trees[shardId].getProof(leaf).map(i => \"0x\" + i.data.toString(\"hex\"));\n    return SnapshotEntryWithProofSchema.parseAsync({\n      ...entry,\n      proof: proof.concat(shard.proofs)\n    });\n  }\n  async getAllEntries() {\n    try {\n      return await this.storage.downloadJSON(this.originalEntriesUri);\n    } catch (e) {\n      console.warn(\"Could not fetch original snapshot entries\", e);\n      return [];\n    }\n  }\n}\n\nasync function fetchSnapshotEntryForAddress(address, merkleRoot, merkleMetadata, provider, storage, snapshotFormatVersion) {\n  if (!merkleMetadata) {\n    return null;\n  }\n  const snapshotUri = merkleMetadata[merkleRoot];\n  if (snapshotUri) {\n    const raw = await storage.downloadJSON(snapshotUri);\n    if (raw.isShardedMerkleTree && raw.merkleRoot === merkleRoot) {\n      const merkleTree = await ShardedMerkleTree.fromShardedMerkleTreeInfo(raw, storage);\n      return await merkleTree.getProof(address, provider, snapshotFormatVersion);\n    }\n    // legacy non-sharded, just fetch it all and filter out\n    const snapshotData = await SnapshotSchema.parseAsync(raw);\n    if (merkleRoot === snapshotData.merkleRoot) {\n      return snapshotData.claims.find(c => c.address.toLowerCase() === address.toLowerCase()) || null;\n    }\n  }\n  return null;\n}\n\nfunction legacyContractModelToAbstract(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot.toString(),\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    maxClaimablePerWallet: model.quantityLimitPerTransaction,\n    waitTimeInSecondsBetweenClaims: model.waitTimeInSecondsBetweenClaims\n  };\n}\n\nfunction newContractModelToAbstract(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot.toString(),\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    maxClaimablePerWallet: model.quantityLimitPerWallet,\n    waitTimeInSecondsBetweenClaims: 0,\n    metadata: model.metadata\n  };\n}\n\nasync function approveErc20Allowance(contractToApprove, currencyAddress, price, quantity, tokenDecimals) {\n  const signer = contractToApprove.getSigner();\n  const provider = contractToApprove.getProvider();\n  const ERC20Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC20.json')).default;\n  const erc20 = new ContractWrapper(signer || provider, currencyAddress, ERC20Abi, contractToApprove.options, contractToApprove.storage);\n  const owner = await contractToApprove.getSignerAddress();\n  const spender = contractToApprove.address;\n  const allowance = await erc20.read(\"allowance\", [owner, spender]);\n  const totalPrice = BigNumber.from(price).mul(BigNumber.from(quantity)).div(utils.parseUnits(\"1\", tokenDecimals));\n  if (allowance.lt(totalPrice)) {\n    await erc20.sendTransaction(\"approve\", [spender, allowance.add(totalPrice)]);\n  }\n}\n\n/**\n * Returns proofs and the overrides required for the transaction.\n * @internal\n * @returns - `overrides` and `proofs` as an object.\n */\nasync function prepareClaim(addressToClaim, quantity, activeClaimCondition, merkleMetadataFetcher, tokenDecimals, contractWrapper, storage, checkERC20Allowance, snapshotFormatVersion) {\n  let maxClaimable = convertQuantityToBigNumber(activeClaimCondition.maxClaimablePerWallet, tokenDecimals);\n  let proofs = [utils.hexZeroPad([0], 32)];\n  let priceInProof = activeClaimCondition.price; // the price to send to the contract in claim proofs\n  let currencyAddressInProof = activeClaimCondition.currencyAddress;\n  try {\n    if (!activeClaimCondition.merkleRootHash.toString().startsWith(constants.AddressZero)) {\n      const snapshotEntry = await fetchSnapshotEntryForAddress(addressToClaim, activeClaimCondition.merkleRootHash.toString(), await merkleMetadataFetcher(), contractWrapper.getProvider(), storage, snapshotFormatVersion);\n      if (snapshotEntry) {\n        proofs = snapshotEntry.proof;\n        // override only if not default values (unlimited for quantity, zero addr for currency)\n        maxClaimable = snapshotEntry.maxClaimable === \"unlimited\" ? constants.MaxUint256 : utils.parseUnits(snapshotEntry.maxClaimable, tokenDecimals);\n        priceInProof = snapshotEntry.price === undefined || snapshotEntry.price === \"unlimited\" ? constants.MaxUint256 : await normalizePriceValue(contractWrapper.getProvider(), snapshotEntry.price, snapshotEntry.currencyAddress || constants.AddressZero);\n        currencyAddressInProof = snapshotEntry.currencyAddress || constants.AddressZero;\n      } else {\n        // if no snapshot entry, and it's a v1 format (exclusive allowlist) then address can't claim\n        if (snapshotFormatVersion === SnapshotFormatVersion.V1) {\n          throw new Error(\"No claim found for this address\");\n        }\n        // but if its snapshot v2 (override list behavior) then address can still claim with default settings\n      }\n    }\n  } catch (e) {\n    // have to handle the valid error case that we *do* want to throw on\n    if (e?.message === \"No claim found for this address\") {\n      throw e;\n    }\n    // other errors we wanna ignore and try to continue\n    console.warn(\"failed to check claim condition merkle root hash, continuing anyways\", e);\n  }\n  const overrides = (await contractWrapper.getCallOverrides()) || {};\n  // the actual price to check allowance against\n  // if proof price is unlimited, then we use the price from the claim condition\n  // this mimics the contract behavior\n  const pricePerToken = priceInProof.toString() !== constants.MaxUint256.toString() ? priceInProof : activeClaimCondition.price;\n  // same for currency address\n  const currencyAddress = currencyAddressInProof !== constants.AddressZero ? currencyAddressInProof : activeClaimCondition.currencyAddress;\n  if (pricePerToken.gt(0)) {\n    if (isNativeToken(currencyAddress)) {\n      overrides[\"value\"] = BigNumber.from(pricePerToken).mul(quantity).div(utils.parseUnits(\"1\", tokenDecimals));\n    } else if (checkERC20Allowance) {\n      await approveErc20Allowance(contractWrapper, currencyAddress, pricePerToken, quantity, tokenDecimals);\n    }\n  }\n  return {\n    overrides,\n    proofs,\n    maxClaimable,\n    price: pricePerToken,\n    currencyAddress: currencyAddress,\n    priceInProof,\n    currencyAddressInProof\n  };\n}\n\n/**\n * @internal\n */\nconst CurrencySchema = /* @__PURE__ */(() => z.object({\n  name: z.string(),\n  symbol: z.string(),\n  decimals: z.number()\n}))();\n\n/**\n * @internal\n */\nconst CurrencyValueSchema = /* @__PURE__ */(() => CurrencySchema.extend({\n  value: BigNumberSchema,\n  displayValue: z.string()\n}))();\n\n/**\n * @internal\n */\nconst ClaimConditionMetadataSchema = /* @__PURE__ */(() => z.object({\n  name: z.string().optional()\n}).catchall(z.unknown()))();\n\n/**\n * @internal\n */\nconst ClaimConditionInputSchema = /* @__PURE__ */(() => z.object({\n  startTime: StartDateSchema,\n  currencyAddress: z.string().default(NATIVE_TOKEN_ADDRESS),\n  price: AmountSchema.default(0),\n  maxClaimableSupply: QuantitySchema,\n  maxClaimablePerWallet: QuantitySchema,\n  waitInSeconds: BigNumberishSchema.default(0),\n  merkleRootHash: BytesLikeSchema.default(utils.hexZeroPad([0], 32)),\n  snapshot: z.optional(SnapshotInputSchema).nullable(),\n  metadata: ClaimConditionMetadataSchema.optional()\n}))();\n\n/**\n * @internal\n */\nconst ClaimConditionInputArray = /* @__PURE__ */(() => z.array(ClaimConditionInputSchema))();\n\n/**\n * @internal\n */\nconst PartialClaimConditionInputSchema = /* @__PURE__ */(() => ClaimConditionInputSchema.partial())();\n\n/**\n * @internal\n */\nconst ClaimConditionOutputSchema = /* @__PURE__ */(() => ClaimConditionInputSchema.extend({\n  availableSupply: QuantitySchema,\n  currentMintSupply: QuantitySchema,\n  currencyMetadata: CurrencyValueSchema.default({\n    value: BigNumber.from(\"0\"),\n    displayValue: \"0\",\n    symbol: \"\",\n    decimals: 18,\n    name: \"\"\n  }),\n  price: BigNumberSchema,\n  waitInSeconds: BigNumberSchema,\n  startTime: BigNumberSchema.transform(n => new Date(n.toNumber() * 1000)),\n  snapshot: SnapshotInputSchema.optional().nullable()\n}))();\n\n/**\n * Create a snapshot (merkle tree) from a list of addresses and uploads it to IPFS\n * @param snapshotInput - the list of addresses to hash\n * @param tokenDecimals - the token decimals\n * @param provider - the provider to use\n * @param storage - the storage to upload to\n * @param snapshotFormatVersion - the snapshot format version\n * @returns the generated snapshot and URI\n * @internal\n */\nasync function createSnapshot(snapshotInput, tokenDecimals, provider, storage, snapshotFormatVersion) {\n  const input = await parseSnapshotInputs(snapshotInput);\n  const addresses = input.map(i => i.address);\n  const hasDuplicates = new Set(addresses).size < addresses.length;\n  if (hasDuplicates) {\n    throw new DuplicateLeafsError();\n  }\n  const tree = await ShardedMerkleTree.buildAndUpload(input, tokenDecimals, provider, storage, snapshotFormatVersion);\n  return {\n    merkleRoot: tree.shardedMerkleInfo.merkleRoot,\n    snapshotUri: tree.uri\n  };\n}\n\nfunction compare(a, b) {\n  const left = BigNumber.from(a);\n  const right = BigNumber.from(b);\n  if (left.eq(right)) {\n    return 0;\n  } else if (left.gt(right)) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\n\n/**\n * @internal\n * Decorates claim conditions with merkle roots from snapshots if present\n * @param claimConditionInputs - The claim conditions to process\n * @param tokenDecimals - The token decimals to use\n * @param provider - The provider to use\n * @param storage - The storage to use\n * @param snapshotFormatVersion - The snapshot format version to use\n */\nasync function processSnapshotData(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion) {\n  const snapshotInfos = [];\n  const inputsWithSnapshots = await Promise.all(claimConditionInputs.map(async conditionInput => {\n    // check snapshots and upload if provided\n    if (conditionInput.snapshot && conditionInput.snapshot.length > 0) {\n      const snapshotInfo = await createSnapshot(conditionInput.snapshot, tokenDecimals, provider, storage, snapshotFormatVersion);\n      snapshotInfos.push(snapshotInfo);\n      conditionInput.merkleRootHash = snapshotInfo.merkleRoot;\n    } else {\n      // if no snapshot is passed or empty, reset the merkle root\n      conditionInput.merkleRootHash = utils.hexZeroPad([0], 32);\n    }\n    // fill condition with defaults values if not provided\n    return conditionInput;\n  }));\n  return {\n    inputsWithSnapshots,\n    snapshotInfos\n  };\n}\n\n/**\n * Converts a local SDK model to contract model\n * @param c - The condition input\n * @param tokenDecimals - The token decimals to use\n * @param provider - The provider to use\n * @param storage - The storage to use\n * @internal\n */\nasync function convertToContractModel(c, tokenDecimals, provider, storage) {\n  const currency = c.currencyAddress === constants.AddressZero ? NATIVE_TOKEN_ADDRESS : c.currencyAddress;\n  const maxClaimableSupply = convertQuantityToBigNumber(c.maxClaimableSupply, tokenDecimals);\n  const maxClaimablePerWallet = convertQuantityToBigNumber(c.maxClaimablePerWallet, tokenDecimals);\n  let metadataOrUri;\n  if (c.metadata) {\n    if (typeof c.metadata === \"string\") {\n      metadataOrUri = c.metadata;\n    } else {\n      metadataOrUri = await storage.upload(c.metadata);\n    }\n  }\n  return {\n    startTimestamp: c.startTime,\n    maxClaimableSupply,\n    supplyClaimed: 0,\n    maxClaimablePerWallet,\n    pricePerToken: await normalizePriceValue(provider, c.price, currency),\n    currency,\n    merkleRoot: c.merkleRootHash.toString(),\n    waitTimeInSecondsBetweenClaims: c.waitInSeconds || 0,\n    metadata: metadataOrUri\n  };\n}\n\n/**\n * Create and uploads snapshots + converts claim conditions to contract format\n * @param claimConditionInputs - The claim conditions to process\n * @param tokenDecimals - The token decimals to use\n * @param provider - The provider to use\n * @param storage - The storage to use\n * @param snapshotFormatVersion - The snapshot format version to use\n * @internal\n */\nasync function processClaimConditionInputs(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion) {\n  const {\n    inputsWithSnapshots,\n    snapshotInfos\n  } = await processSnapshotData(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion);\n  const parsedInputs = await ClaimConditionInputArray.parseAsync(inputsWithSnapshots);\n  // Convert processed inputs to the format the contract expects, and sort by timestamp\n  const sortedConditions = (await Promise.all(parsedInputs.map(c => convertToContractModel(c, tokenDecimals, provider, storage)))).sort((a, b) => {\n    return compare(a.startTimestamp, b.startTimestamp);\n  });\n  return {\n    snapshotInfos,\n    sortedConditions\n  };\n}\n\n/**\n * @internal\n * @param merkleRoot - The merkle root to fetch the snapshot for\n * @param merkleMetadata - The merkle metadata to use\n * @param storage - The storage to use\n */\nasync function fetchSnapshot(merkleRoot, merkleMetadata, storage) {\n  if (!merkleMetadata) {\n    return null;\n  }\n  const snapshotUri = merkleMetadata[merkleRoot];\n  if (snapshotUri) {\n    const raw = await storage.downloadJSON(snapshotUri);\n    if (raw.isShardedMerkleTree && raw.merkleRoot === merkleRoot) {\n      const smt = await ShardedMerkleTree.fromUri(snapshotUri, storage);\n      return smt?.getAllEntries() || null;\n    } else {\n      const snapshotData = await SnapshotSchema.parseAsync(raw);\n      if (merkleRoot === snapshotData.merkleRoot) {\n        return snapshotData.claims.map(claim => ({\n          address: claim.address,\n          maxClaimable: claim.maxClaimable,\n          price: claim.price,\n          currencyAddress: claim.currencyAddress\n        }));\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * @internal\n * @param bn - The big number to convert\n * @param tokenDecimals - The token decimals to use\n */\nfunction convertToReadableQuantity(bn, tokenDecimals) {\n  if (bn.toString() === constants.MaxUint256.toString()) {\n    return \"unlimited\";\n  } else {\n    return utils.formatUnits(bn, tokenDecimals);\n  }\n}\n\n/**\n * Transforms a contract model to local model\n * @param pm - The contract model to transform\n * @param tokenDecimals - The token decimals to use\n * @param provider - The provider to use\n * @param merkleMetadata - The merkle metadata to use\n * @param storage - The storage to use\n * @param shouldDownloadSnapshot - Whether to download the snapshot\n * @internal\n */\nasync function transformResultToClaimCondition(pm, tokenDecimals, provider, merkleMetadata, storage, shouldDownloadSnapshot) {\n  const cv = await fetchCurrencyValue(provider, pm.currency, pm.pricePerToken);\n  const maxClaimableSupply = convertToReadableQuantity(pm.maxClaimableSupply, tokenDecimals);\n  const maxClaimablePerWallet = convertToReadableQuantity(pm.maxClaimablePerWallet, tokenDecimals);\n  const availableSupply = convertToReadableQuantity(BigNumber.from(pm.maxClaimableSupply).sub(pm.supplyClaimed), tokenDecimals);\n  const currentMintSupply = convertToReadableQuantity(pm.supplyClaimed, tokenDecimals);\n  let resolvedMetadata;\n  if (pm.metadata) {\n    resolvedMetadata = await storage.downloadJSON(pm.metadata);\n  }\n  return ClaimConditionOutputSchema.parseAsync({\n    startTime: pm.startTimestamp,\n    maxClaimableSupply,\n    maxClaimablePerWallet,\n    currentMintSupply,\n    availableSupply,\n    waitInSeconds: pm.waitTimeInSecondsBetweenClaims?.toString(),\n    price: BigNumber.from(pm.pricePerToken),\n    currency: pm.currency,\n    currencyAddress: pm.currency,\n    currencyMetadata: cv,\n    merkleRootHash: pm.merkleRoot,\n    snapshot: shouldDownloadSnapshot ? await fetchSnapshot(pm.merkleRoot, merkleMetadata, storage) : undefined,\n    metadata: resolvedMetadata\n  });\n}\n\n/**\n * @internal\n * @param index - The index of the condition to update\n * @param claimConditionInput - The input claim condition to update\n * @param existingConditions - The existing claim conditions\n */\nasync function updateExistingClaimConditions(index, claimConditionInput, existingConditions) {\n  if (index >= existingConditions.length) {\n    throw Error(`Index out of bounds - got index: ${index} with ${existingConditions.length} conditions`);\n  }\n  // merge input with existing claim condition\n  const priceDecimals = existingConditions[index].currencyMetadata.decimals;\n  const priceInWei = existingConditions[index].price;\n  const priceInTokens = utils.formatUnits(priceInWei, priceDecimals);\n\n  // merge existing (output format) with incoming (input format)\n  const newConditionParsed = await ClaimConditionInputSchema.parseAsync({\n    ...existingConditions[index],\n    price: priceInTokens,\n    ...claimConditionInput\n  });\n\n  // convert to output claim condition\n  const mergedConditionOutput = await ClaimConditionOutputSchema.parseAsync({\n    ...newConditionParsed,\n    price: priceInWei\n  });\n  return existingConditions.map((existingOutput, i) => {\n    let newConditionAtIndex;\n    if (i === index) {\n      newConditionAtIndex = mergedConditionOutput;\n    } else {\n      newConditionAtIndex = existingOutput;\n    }\n    const formattedPrice = utils.formatUnits(newConditionAtIndex.price, priceDecimals);\n    return {\n      ...newConditionAtIndex,\n      price: formattedPrice // manually transform back to input price type\n    };\n  });\n}\n\nlet ClaimEligibility = /*#__PURE__*/function (ClaimEligibility) {\n  ClaimEligibility[\"NotEnoughSupply\"] = \"There is not enough supply to claim.\";\n  ClaimEligibility[\"AddressNotAllowed\"] = \"This address is not on the allowlist.\";\n  ClaimEligibility[\"WaitBeforeNextClaimTransaction\"] = \"Not enough time since last claim transaction. Please wait.\";\n  ClaimEligibility[\"ClaimPhaseNotStarted\"] = \"Claim phase has not started yet.\";\n  ClaimEligibility[\"AlreadyClaimed\"] = \"You have already claimed the token.\";\n  ClaimEligibility[\"WrongPriceOrCurrency\"] = \"Incorrect price or currency.\";\n  ClaimEligibility[\"OverMaxClaimablePerWallet\"] = \"Cannot claim more than maximum allowed quantity.\";\n  ClaimEligibility[\"NotEnoughTokens\"] = \"There are not enough tokens in the wallet to pay for the claim.\";\n  ClaimEligibility[\"NoActiveClaimPhase\"] = \"There is no active claim phase at the moment. Please check back in later.\";\n  ClaimEligibility[\"NoClaimConditionSet\"] = \"There is no claim condition set.\";\n  ClaimEligibility[\"NoWallet\"] = \"No wallet connected.\";\n  ClaimEligibility[\"Unknown\"] = \"No claim conditions found.\";\n  return ClaimEligibility;\n}({});\n\nfunction resolveOrGenerateId(requestUId) {\n  if (requestUId === undefined) {\n    const buffer = Buffer.alloc(16);\n    v4({}, buffer);\n    return utils.hexlify(utils.toUtf8Bytes(buffer.toString(\"hex\")));\n  } else {\n    return utils.hexlify(requestUId);\n  }\n}\n\n/**\n * @internal\n */\nconst BaseSignaturePayloadInput = /* @__PURE__ */(() => z.object({\n  to: AddressOrEnsSchema.refine(address => address.toLowerCase() !== constants.AddressZero, {\n    message: \"Cannot create payload to mint to zero address\"\n  }),\n  price: AmountSchema.default(0),\n  currencyAddress: AddressSchema.default(NATIVE_TOKEN_ADDRESS),\n  mintStartTime: StartDateSchema,\n  mintEndTime: EndDateSchema,\n  uid: z.string().optional().transform(arg => resolveOrGenerateId(arg)),\n  primarySaleRecipient: AddressOrEnsSchema.default(constants.AddressZero)\n}))();\n\n/**\n * @internal\n */\nconst Signature20PayloadInput = /* @__PURE__ */(() => BaseSignaturePayloadInput.extend({\n  quantity: AmountSchema\n}))();\n\n/**\n * @internal\n */\nconst Signature20PayloadOutput = /* @__PURE__ */(() => Signature20PayloadInput.extend({\n  mintStartTime: BigNumberSchema,\n  mintEndTime: BigNumberSchema\n}))();\n\n/**\n * @internal\n */\nconst Signature721PayloadInput = /* @__PURE__ */(() => BaseSignaturePayloadInput.extend({\n  metadata: NFTInputOrUriSchema,\n  royaltyRecipient: z.string().default(constants.AddressZero),\n  royaltyBps: BasisPointsSchema.default(0)\n}))();\n\n/**\n * @internal\n */\nconst Signature721PayloadOutput = /* @__PURE__ */(() => Signature721PayloadInput.extend({\n  metadata: NFTInputOrUriSchema.default(\"\"),\n  uri: z.string(),\n  royaltyBps: BigNumberSchema,\n  mintStartTime: BigNumberSchema,\n  mintEndTime: BigNumberSchema\n}))();\n\n/**\n * @internal\n */\nconst Signature1155PayloadInput = /* @__PURE__ */(() => Signature721PayloadInput.extend({\n  metadata: NFTInputOrUriSchema.default(\"\"),\n  quantity: BigNumberishSchema\n}))();\n\n/**\n * @internal\n */\nconst Signature1155PayloadInputWithTokenId = /* @__PURE__ */(() => Signature1155PayloadInput.extend({\n  tokenId: BigNumberishSchema\n}))();\n\n/**\n * @internal\n */\nconst Signature1155PayloadOutput = /* @__PURE__ */(() => Signature721PayloadOutput.extend({\n  tokenId: BigNumberSchema,\n  quantity: BigNumberSchema\n}))();\n\n/**\n * @internal\n */\nconst Signature721WithQuantityInput = /* @__PURE__ */(() => Signature721PayloadInput.extend({\n  metadata: NFTInputOrUriSchema.default(\"\"),\n  quantity: BigNumberSchema.default(1)\n}))();\n\n/**\n * @internal\n */\nconst Signature721WithQuantityOutput = /* @__PURE__ */(() => Signature721PayloadOutput.extend({\n  quantity: BigNumberSchema.default(1)\n}))();\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\nconst MintRequest20 = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"quantity\",\n  type: \"uint256\"\n}, {\n  name: \"price\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst MintRequest721 = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"royaltyRecipient\",\n  type: \"address\"\n}, {\n  name: \"royaltyBps\",\n  type: \"uint256\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"uri\",\n  type: \"string\"\n}, {\n  name: \"price\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst MintRequest1155 = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"royaltyRecipient\",\n  type: \"address\"\n}, {\n  name: \"royaltyBps\",\n  type: \"uint256\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"tokenId\",\n  type: \"uint256\"\n}, {\n  name: \"uri\",\n  type: \"string\"\n}, {\n  name: \"quantity\",\n  type: \"uint256\"\n}, {\n  name: \"pricePerToken\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst MintRequest721withQuantity = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"royaltyRecipient\",\n  type: \"address\"\n}, {\n  name: \"royaltyBps\",\n  type: \"uint256\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"uri\",\n  type: \"string\"\n}, {\n  name: \"quantity\",\n  type: \"uint256\"\n}, {\n  name: \"pricePerToken\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst GenericRequest = [{\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}, {\n  name: \"data\",\n  type: \"bytes\"\n}];\n\nexport { SnapshotFormatVersion as A, BaseSignaturePayloadInput as B, ClaimEligibility as C, processClaimConditionInputs as D, abstractContractModelToLegacy as E, abstractContractModelToNew as F, GenericRequest as G, updateExistingClaimConditions as H, resolveOrGenerateId as I, MintRequest20 as M, PartialClaimConditionInputSchema as P, Signature20PayloadInput as S, approveErc20Allowance as a, createSnapshot as b, convertToReadableQuantity as c, ClaimConditionMetadataSchema as d, ClaimConditionInputSchema as e, fetchSnapshotEntryForAddress as f, ClaimConditionInputArray as g, ClaimConditionOutputSchema as h, CurrencySchema as i, CurrencyValueSchema as j, Signature20PayloadOutput as k, Signature721PayloadInput as l, Signature721PayloadOutput as m, Signature1155PayloadInput as n, Signature1155PayloadInputWithTokenId as o, Signature1155PayloadOutput as p, Signature721WithQuantityInput as q, Signature721WithQuantityOutput as r, MintRequest721 as s, MintRequest1155 as t, MintRequest721withQuantity as u, transformResultToClaimCondition as v, legacyContractModelToAbstract as w, newContractModelToAbstract as x, convertQuantityToBigNumber as y, prepareClaim as z };\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","module.exports = function reverse (src) {\n  var buffer = new Buffer(src.length)\n\n  for (var i = 0, j = src.length - 1; i <= j; ++i, --j) {\n    buffer[i] = src[j]\n    buffer[j] = src[i]\n  }\n\n  return buffer\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","//     treeify.js\n//     Luke Plaster <notatestuser@gmail.com>\n//     https://github.com/notatestuser/treeify.js\n\n// do the universal module definition dance\n(function (root, factory) {\n\n  if (typeof exports === 'object') {\n    module.exports = factory();\n  } else if (typeof define === 'function' && define.amd) {\n    define(factory);\n  } else {\n    root.treeify = factory();\n  }\n\n}(this, function() {\n\n  function makePrefix(key, last) {\n    var str = (last ? '' : '');\n    if (key) {\n      str += ' ';\n    } else {\n      str += '';\n    }\n    return str;\n  }\n\n  function filterKeys(obj, hideFunctions) {\n    var keys = [];\n    for (var branch in obj) {\n      // always exclude anything in the object's prototype\n      if (!obj.hasOwnProperty(branch)) {\n        continue;\n      }\n      // ... and hide any keys mapped to functions if we've been told to\n      if (hideFunctions && ((typeof obj[branch])===\"function\")) {\n        continue;\n      }\n      keys.push(branch);\n    }\n    return keys;\n  }\n\n  function growBranch(key, root, last, lastStates, showValues, hideFunctions, callback) {\n    var line = '', index = 0, lastKey, circular, lastStatesCopy = lastStates.slice(0);\n\n    if (lastStatesCopy.push([ root, last ]) && lastStates.length > 0) {\n      // based on the \"was last element\" states of whatever we're nested within,\n      // we need to append either blankness or a branch to our line\n      lastStates.forEach(function(lastState, idx) {\n        if (idx > 0) {\n          line += (lastState[1] ? ' ' : '') + '  ';\n        }\n        if ( ! circular && lastState[0] === root) {\n          circular = true;\n        }\n      });\n\n      // the prefix varies based on whether the key contains something to show and\n      // whether we're dealing with the last element in this collection\n      line += makePrefix(key, last) + key;\n\n      // append values and the circular reference indicator\n      showValues && (typeof root !== 'object' || root instanceof Date) && (line += ': ' + root);\n      circular && (line += ' (circular ref.)');\n\n      callback(line);\n    }\n\n    // can we descend into the next item?\n    if ( ! circular && typeof root === 'object') {\n      var keys = filterKeys(root, hideFunctions);\n      keys.forEach(function(branch){\n        // the last key is always printed with a different prefix, so we'll need to know if we have it\n        lastKey = ++index === keys.length;\n\n        // hold your breath for recursive action\n        growBranch(branch, root[branch], lastKey, lastStatesCopy, showValues, hideFunctions, callback);\n      });\n    }\n  };\n\n  // --------------------\n\n  var Treeify = {};\n\n  // Treeify.asLines\n  // --------------------\n  // Outputs the tree line-by-line, calling the lineCallback when each one is available.\n\n  Treeify.asLines = function(obj, showValues, hideFunctions, lineCallback) {\n    /* hideFunctions and lineCallback are curried, which means we don't break apps using the older form */\n    var hideFunctionsArg = typeof hideFunctions !== 'function' ? hideFunctions : false;\n    growBranch('.', obj, false, [], showValues, hideFunctionsArg, lineCallback || hideFunctions);\n  };\n\n  // Treeify.asTree\n  // --------------------\n  // Outputs the entire tree, returning it as a string with line breaks.\n\n  Treeify.asTree = function(obj, showValues, hideFunctions) {\n    var tree = '';\n    growBranch('.', obj, false, [], showValues, hideFunctions, function(line) {\n      tree += line + '\\n';\n    });\n    return tree;\n  };\n\n  // --------------------\n\n  return Treeify;\n\n}));\n"],"names":["RawDateSchema","z","union","date","transform","i","BigNumber","from","Math","floor","getTime","number","StartDateSchema","default","Date","EndDateSchema","now","assertEnabled","namespace","feature","ExtensionNotImplementedError","PropertiesInput","object","catchall","BigNumberTransformSchema","unknown","OptionalPropertiesInput","array","optional","nullable","BasicNFTInput","name","string","description","image","FileOrBufferOrStringSchema","animation_url","CommonNFTInput","extend","external_url","background_color","HexColor","properties","attributes","NFTInputOrUriSchema","CommonNFTOutput","id","uri","async","setErc20Allowance","contractToApprove","value","currencyAddress","overrides","isNativeToken","ERC20Abi","signer","getSigner","provider","getProvider","erc20","ContractWrapper","options","storage","owner","getSignerAddress","spender","address","read","lt","sendTransaction","Base","print","this","bufferIndexOf","element","arguments","length","undefined","binarySearch","Buffer","compare","linearSearch","eqChecker","buffer1","buffer2","equals","compareFunction","start","end","mid","ordering","bufferify","isBuffer","words","toString","convertWordsToBuffer","isHexString","replace","Uint8Array","buffer","s","concat","ArrayBuffer","isView","byteOffset","byteLength","bigNumberify","startsWith","BigInt","u8a","hex","Array","map","byte","padStart","join","uint8ArrayToBigInt","Error","v","test","tree","console","log","bufferToHex","withPrefix","alloc","bufferifyFn","f","arrayBuffer","hexString","parseInt","substring","hexStringToArrayBuffer","hexResult","uint8View","arrayBufferToHexString","log2","n","zip","a","b","e","hexZeroPad","hexStr","Base$1","wordArray","MerkleTree","constructor","leaves","hashFn","super","_defineProperty","complete","isBitcoinTree","duplicateOdd","hashLeaves","sortLeaves","sortPairs","fillDefaultHash","idx","sort","concatenator","processLeaves","getOptions","_this$fillDefaultHash","_this$fillDefaultHash2","pow","ceil","push","createHashes","nodes","layers","layerIndex","layerLimit","Number","isInteger","slice","data","hash","reverse","left","right","combined","addLeaf","leaf","addLeaves","getLeaves","values","isArray","filter","getLeaf","index","getLeafIndex","target","getLeafCount","getHexLeaves","marshalLeaves","JSON","stringify","unmarshalLeaves","jsonStr","parsed","parse","Object","getLayers","getHexLayers","reduce","acc","item","layer","getLayersFlat","unshift","getHexLayersFlat","getLayerCount","getRoot","getHexRoot","getProof","proof","isRightNode","pairIndex","position","getHexProof","getProofs","proofs","getProofsDFS","currentLayer","pushed","leftchildIndex","rightchildIndex","splice","getHexProofs","getPositionalHexProof","getProofIndices","treeIndices","depth","leafCount","maximalIndices","Set","x","add","y","redundantIndices","has","includes","getProofIndicesForUnevenTree","sortedLeafIndices","leavesCount","unevenLayers","proofIndices","layerNodes","proofNodeIndices","unevenLayer","find","_ref","getMultiProof","indices","warn","isUnevenTree","every","getMultiProofForUnevenTree","els","ids","el","hashes","nextIds","j","pairElement","getPairNode","self","indexOf","proofHashes","currentLayerIndices","treeLayer","siblings","uniqueIndices","getHexMultiProof","getProofFlags","_proofs","tested","flags","ids_","proofUsed","verify","targetNode","root","node","isLeftNode","buffers","verifyMultiProof","proofLeaves","verifyMultiProofForUnevenTree","proofitem","indexqueue","keys","hasOwnProperty","call","pair","verifyMultiProofWithFlags","proofFlag","leavesLen","totalHashes","leafPos","hashPos","proofPos","computedRoot","calculateRootForUnevenTree","getDepth","getLayersAsObject","objs","arr","obj","shift","akey","bkey","resetTree","pairIdx","toTreeString","asTree","treeLayers","isPowOf2","leafIndices","leafHashes","totalLeavesCount","leafTuples","_ref2","_ref3","indexA","indexB","leafTupleIndices","_ref4","nextSliceStart","proofTuplesByLayers","sliceStart","_ref5","_ref6","_ref7","_ref8","layerIndex_","parentIndices","parentLayer","parentNodeTreeIndex","bufA","bufB","randomUUID","crypto","bind","getRandomValues","rnds8","rng","byteToHex","unsafeStringify","offset","buf","native","rnds","random","abstractContractModelToLegacy","model","startTimestamp","maxClaimableSupply","supplyClaimed","merkleRoot","pricePerToken","currency","quantityLimitPerTransaction","maxClaimablePerWallet","waitTimeInSecondsBetweenClaims","abstractContractModelToNew","quantityLimitPerWallet","metadata","convertQuantityToBigNumber","quantity","tokenDecimals","constants","utils","parseSnapshotInputs","inputs","chunkSize","chunks","_","results","parsedChunks","Promise","all","chunk","SnapshotInputSchema","parseAsync","SnapshotFormatVersion","ShardedMerkleTree","baseUri","originalEntriesUri","shardNybbles","shards","trees","fromUri","shardedMerkleTreeInfo","downloadJSON","isShardedMerkleTree","fromShardedMerkleTreeInfo","info","hashEntry","entry","currencyDecimals","snapshotFormatVersion","V1","maxClaimable","V2","price","fetchAndCacheDecimals","cache","fetchCurrencyMetadata","decimals","buildAndUpload","snapshotInput","snapshotEntry","shard","toLowerCase","currencyDecimalMap","subTrees","entries","roots","fromEntries","shardsToUpload","shardId","uris","uploadBatch","lastIndexOf","upload","shardedMerkleInfo","endsWith","hashedEntries","SnapshotEntryWithProofSchema","getAllEntries","fetchSnapshotEntryForAddress","merkleMetadata","snapshotUri","raw","merkleTree","snapshotData","SnapshotSchema","claims","c","legacyContractModelToAbstract","newContractModelToAbstract","approveErc20Allowance","allowance","totalPrice","mul","div","prepareClaim","addressToClaim","activeClaimCondition","merkleMetadataFetcher","contractWrapper","checkERC20Allowance","priceInProof","currencyAddressInProof","merkleRootHash","normalizePriceValue","message","getCallOverrides","gt","CurrencySchema","symbol","CurrencyValueSchema","BigNumberSchema","displayValue","ClaimConditionMetadataSchema","ClaimConditionInputSchema","startTime","NATIVE_TOKEN_ADDRESS","AmountSchema","QuantitySchema","waitInSeconds","BigNumberishSchema","BytesLikeSchema","snapshot","ClaimConditionInputArray","ClaimConditionOutputSchema","availableSupply","currentMintSupply","currencyMetadata","toNumber","processSnapshotData","claimConditionInputs","snapshotInfos","inputsWithSnapshots","conditionInput","snapshotInfo","input","addresses","size","DuplicateLeafsError","createSnapshot","processClaimConditionInputs","parsedInputs","sortedConditions","metadataOrUri","convertToContractModel","eq","fetchSnapshot","smt","claim","convertToReadableQuantity","bn","transformResultToClaimCondition","pm","shouldDownloadSnapshot","_pm$waitTimeInSeconds","cv","fetchCurrencyValue","sub","resolvedMetadata","updateExistingClaimConditions","claimConditionInput","existingConditions","priceDecimals","priceInWei","priceInTokens","newConditionParsed","mergedConditionOutput","existingOutput","newConditionAtIndex","formattedPrice","ClaimEligibility","resolveOrGenerateId","requestUId","v4","BaseSignaturePayloadInput","to","AddressOrEnsSchema","refine","AddressSchema","mintStartTime","mintEndTime","uid","arg","primarySaleRecipient","Signature20PayloadInput","Signature20PayloadOutput","Signature721PayloadInput","royaltyRecipient","royaltyBps","BasisPointsSchema","Signature721PayloadOutput","Signature1155PayloadInput","Signature1155PayloadInputWithTokenId","tokenId","Signature1155PayloadOutput","Signature721WithQuantityInput","Signature721WithQuantityOutput","MintRequest20","type","MintRequest721","MintRequest1155","MintRequest721withQuantity","exports","b64","lens","getLens","validLen","placeHoldersLen","toByteArray","tmp","Arr","_byteLength","curByte","len","revLookup","charCodeAt","fromByteArray","uint8","extraBytes","parts","maxChunkLength","len2","encodeChunk","lookup","code","num","output","module","src","base64","require","ieee754","customInspectSymbol","Symbol","K_MAX_LENGTH","createBuffer","RangeError","setPrototypeOf","prototype","encodingOrOffset","TypeError","allocUnsafe","encoding","isEncoding","actual","write","fromString","arrayView","isInstance","copy","fromArrayBuffer","fromArrayLike","fromArrayView","SharedArrayBuffer","valueOf","checked","numberIsNaN","fromObject","toPrimitive","assertSize","mustMatch","loweredCase","utf8ToBytes","base64ToBytes","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","m","bidirectionalIndexOf","val","dir","arrayIndexOf","indexSize","arrLength","valLength","String","readUInt16BE","foundIndex","found","hexWrite","remaining","strLen","substr","utf8Write","blitBuffer","asciiWrite","str","byteArray","asciiToBytes","base64Write","ucs2Write","units","hi","lo","utf16leToBytes","min","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","apply","decodeCodePointsArray","TYPED_ARRAY_SUPPORT","proto","foo","typedArraySupport","error","defineProperty","enumerable","get","poolSize","fill","allocUnsafeSlow","_isBuffer","list","pos","set","swap16","swap32","swap64","toLocaleString","inspect","max","trim","thisStart","thisEnd","thisCopy","targetCopy","isFinite","toJSON","_arr","ret","out","hexSliceLookupTable","bytes","checkOffset","ext","checkInt","wrtBigUInt64LE","checkIntBI","wrtBigUInt64BE","checkIEEE754","writeFloat","littleEndian","noAssert","writeDouble","newBuf","subarray","readUintLE","readUIntLE","readUintBE","readUIntBE","readUint8","readUInt8","readUint16LE","readUInt16LE","readUint16BE","readUint32LE","readUInt32LE","readUint32BE","readUInt32BE","readBigUInt64LE","defineBigIntMethod","validateNumber","first","last","boundsError","readBigUInt64BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readBigInt64LE","readBigInt64BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUintLE","writeUIntLE","writeUintBE","writeUIntBE","writeUint8","writeUInt8","writeUint16LE","writeUInt16LE","writeUint16BE","writeUInt16BE","writeUint32LE","writeUInt32LE","writeUint32BE","writeUInt32BE","writeBigUInt64LE","writeBigUInt64BE","writeIntLE","limit","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeBigInt64LE","writeBigInt64BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","errors","E","sym","getMessage","writable","configurable","stack","addNumericalSeparator","range","ERR_OUT_OF_RANGE","checkBounds","ERR_INVALID_ARG_TYPE","ERR_BUFFER_OUT_OF_BOUNDS","msg","received","abs","INVALID_BASE64_RE","Infinity","leadSurrogate","split","base64clean","dst","alphabet","table","i16","fn","BufferBigIntNotDefined","equal","RegExp","source","key","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","d","NaN","rt","isNaN","LN2","makePrefix","filterKeys","hideFunctions","branch","growBranch","lastStates","showValues","callback","lastKey","circular","line","lastStatesCopy","forEach","lastState","Treeify","lineCallback","factory"],"sourceRoot":""}